diff --git a/frameworks/native/build/phone-hdpi-512-dalvik-heap.mk b/frameworks/native/build/phone-hdpi-512-dalvik-heap.mk
index 102c3f1..6b97545 100644
--- a/frameworks/native/build/phone-hdpi-512-dalvik-heap.mk
+++ b/frameworks/native/build/phone-hdpi-512-dalvik-heap.mk
@@ -21,6 +21,6 @@ PRODUCT_PROPERTY_OVERRIDES += \
     dalvik.vm.heapstartsize=5m \
     dalvik.vm.heapgrowthlimit=48m \
     dalvik.vm.heapsize=128m \
-    dalvik.vm.heaptargetutilization=0.75 \
+    dalvik.vm.heaptargetutilization=0.25 \
     dalvik.vm.heapminfree=512k \
     dalvik.vm.heapmaxfree=2m
diff --git a/frameworks/native/build/phone-xhdpi-1024-dalvik-heap.mk b/frameworks/native/build/phone-xhdpi-1024-dalvik-heap.mk
index 221227d..e6af2f7 100644
--- a/frameworks/native/build/phone-xhdpi-1024-dalvik-heap.mk
+++ b/frameworks/native/build/phone-xhdpi-1024-dalvik-heap.mk
@@ -18,8 +18,8 @@
 
 PRODUCT_PROPERTY_OVERRIDES += \
     dalvik.vm.heapstartsize=8m \
-    dalvik.vm.heapgrowthlimit=96m \
+    dalvik.vm.heapgrowthlimit=64m \
     dalvik.vm.heapsize=256m \
     dalvik.vm.heaptargetutilization=0.75 \
-    dalvik.vm.heapminfree=512k \
+    dalvik.vm.heapminfree=2m \
     dalvik.vm.heapmaxfree=8m
diff --git a/frameworks/native/cmds/dumpstate/utils.c b/frameworks/native/cmds/dumpstate/utils.c
index fe716ac..5038603 100644
--- a/frameworks/native/cmds/dumpstate/utils.c
+++ b/frameworks/native/cmds/dumpstate/utils.c
@@ -201,12 +201,23 @@ void do_dmesg() {
 }
 
 void do_showmap(int pid, const char *name) {
+    static bool ran = false, skip = false;
     char title[255];
     char arg[255];
 
     sprintf(title, "SHOW MAP %d (%s)", pid, name);
     sprintf(arg, "%d", pid);
-    run_command(title, 10, SU_PATH, "root", "showmap", arg, NULL);
+
+    if (skip) {
+        /* Skip due to non-zero exit status on first run. */
+        printf("------ %s: Skipped. ------\n", title);
+    } else {
+        int status = run_command(title, 10, SU_PATH, "root", "showmap", arg, NULL);
+        if (!ran) {
+            ran  = true;
+            skip = !WIFEXITED(status) || WEXITSTATUS(status) != 0;
+        }
+    }
 }
 
 /* prints the contents of a file */
@@ -265,7 +276,21 @@ int run_command(const char *title, int timeout_seconds, const char *command, ...
     /* handle child case */
     if (pid == 0) {
         const char *args[1024] = {command};
-        size_t arg;
+        size_t arg = 1;
+        char sucmd[255];
+        bool su = false;
+
+        if (strcmp(command, SU_PATH) == 0) {
+            /* Need to transform calls to su from:
+             *   su LOGIN COMMAND ...
+             * to:
+             *   su -c 'COMMAND "$@"' -- LOGIN COMMAND ... */
+            args[arg++] = "-c";
+            args[arg++] = sucmd;
+            args[arg++] = "--";
+            sucmd[0] = '\0';
+            su = true;
+        }
 
         /* make sure the child dies when dumpstate dies */
         prctl(PR_SET_PDEATHSIG, SIGKILL);
@@ -273,9 +298,10 @@ int run_command(const char *title, int timeout_seconds, const char *command, ...
         va_list ap;
         va_start(ap, command);
         if (title) printf("------ %s (%s", title, command);
-        for (arg = 1; arg < sizeof(args) / sizeof(args[0]); ++arg) {
+        for (; arg < sizeof(args) / sizeof(args[0]); ++arg) {
             args[arg] = va_arg(ap, const char *);
             if (args[arg] == NULL) break;
+            if (su && arg == 5) snprintf(sucmd, sizeof(sucmd), "%s \"$@\"", args[arg]);
             if (title) printf(" %s", args[arg]);
         }
         if (title) printf(") ------\n");
diff --git a/frameworks/native/cmds/installd/commands.c b/frameworks/native/cmds/installd/commands.c
index 84ad204..7d9e2cd 100644
--- a/frameworks/native/cmds/installd/commands.c
+++ b/frameworks/native/cmds/installd/commands.c
@@ -21,6 +21,7 @@
 
 /* Directory records that are used in execution of commands. */
 dir_rec_t android_data_dir;
+dir_rec_t android_datadata_dir;
 dir_rec_t android_asec_dir;
 dir_rec_t android_app_dir;
 dir_rec_t android_app_private_dir;
@@ -545,6 +546,7 @@ int create_cache_path(char path[PKG_PATH_MAX], const char *src)
     char *tmp;
     int srclen;
     int dstlen;
+    char dexopt_data_only[PROPERTY_VALUE_MAX];
 
     srclen = strlen(src);
 
@@ -557,7 +559,15 @@ int create_cache_path(char path[PKG_PATH_MAX], const char *src)
         return -1;
     }
 
-    dstlen = srclen + strlen(DALVIK_CACHE_PREFIX) + 
+    const char *cache_path = DALVIK_CACHE_PREFIX;
+    if (!strncmp(src, "/system", 7)) {
+        property_get("dalvik.vm.dexopt-data-only", dexopt_data_only, "1");
+        if (strcmp(dexopt_data_only, "1") != 0) {
+            cache_path = DALVIK_SYSTEM_CACHE_PREFIX;
+        }
+    }
+
+    dstlen = srclen + strlen(cache_path) + 
         strlen(DALVIK_CACHE_POSTFIX) + 1;
     
     if (dstlen > PKG_PATH_MAX) {
@@ -565,11 +575,11 @@ int create_cache_path(char path[PKG_PATH_MAX], const char *src)
     }
 
     sprintf(path,"%s%s%s",
-            DALVIK_CACHE_PREFIX,
+            cache_path,
             src + 1, /* skip the leading / */
             DALVIK_CACHE_POSTFIX);
     
-    for(tmp = path + strlen(DALVIK_CACHE_PREFIX); *tmp; tmp++) {
+    for(tmp = path + strlen(cache_path); *tmp; tmp++) {
         if (*tmp == '/') {
             *tmp = '@';
         }
diff --git a/frameworks/native/cmds/installd/installd.c b/frameworks/native/cmds/installd/installd.c
index 1904408..76c3feb 100644
--- a/frameworks/native/cmds/installd/installd.c
+++ b/frameworks/native/cmds/installd/installd.c
@@ -268,6 +268,11 @@ int initialize_globals() {
         return -1;
     }
 
+    // Get the android datadata directory.
+    if (copy_and_append(&android_datadata_dir, &android_data_dir, DATA_SUBDIR) < 0) {
+        return -1;
+    }
+
     // Get the android app directory.
     if (copy_and_append(&android_app_dir, &android_data_dir, APP_SUBDIR) < 0) {
         return -1;
diff --git a/frameworks/native/cmds/installd/installd.h b/frameworks/native/cmds/installd/installd.h
index 635b07c..8de88c5 100644
--- a/frameworks/native/cmds/installd/installd.h
+++ b/frameworks/native/cmds/installd/installd.h
@@ -60,6 +60,8 @@
 
 #define CACHE_DIR_POSTFIX      "/cache"
 
+#define DATA_SUBDIR             "data/" // sub-directory under ANDROID_DATA
+
 #define APP_SUBDIR             "app/" // sub-directory under ANDROID_DATA
 
 #define APP_LIB_SUBDIR         "app-lib/" // sub-directory under ANDROID_DATA
@@ -72,6 +74,7 @@
 
 #define DALVIK_CACHE_PREFIX    "/data/dalvik-cache/"
 #define DALVIK_CACHE_POSTFIX   "/classes.dex"
+#define DALVIK_SYSTEM_CACHE_PREFIX "/cache/dalvik-cache/"
 
 #define UPDATE_COMMANDS_DIR_PREFIX  "/system/etc/updatecmds/"
 
@@ -94,6 +97,7 @@ extern dir_rec_t android_app_dir;
 extern dir_rec_t android_app_private_dir;
 extern dir_rec_t android_app_lib_dir;
 extern dir_rec_t android_data_dir;
+extern dir_rec_t android_datadata_dir;
 extern dir_rec_t android_asec_dir;
 extern dir_rec_t android_media_dir;
 extern dir_rec_array_t android_system_dirs;
diff --git a/frameworks/native/cmds/installd/utils.c b/frameworks/native/cmds/installd/utils.c
index ef634c6..722ed50 100644
--- a/frameworks/native/cmds/installd/utils.c
+++ b/frameworks/native/cmds/installd/utils.c
@@ -363,7 +363,11 @@ int lookup_media_dir(char basepath[PATH_MAX], const char *dir)
 int64_t data_disk_free()
 {
     struct statfs sfs;
-    if (statfs(android_data_dir.path, &sfs) == 0) {
+    /* Scanning /data/data because on some devices, it's on a different partition
+     * and scanning /data will yield the incorrect result. (This function is only
+     * used for freeing space on /data/data so it is okay to be more specific.)
+     */
+    if (statfs(android_datadata_dir.path, &sfs) == 0) {
         return sfs.f_bavail * sfs.f_bsize;
     } else {
         ALOGE("Couldn't statfs %s: %s\n", android_data_dir.path, strerror(errno));
diff --git a/frameworks/native/cmds/servicemanager/Android.mk b/frameworks/native/cmds/servicemanager/Android.mk
index 8840867..07860e5 100644
--- a/frameworks/native/cmds/servicemanager/Android.mk
+++ b/frameworks/native/cmds/servicemanager/Android.mk
@@ -9,4 +9,10 @@ include $(CLEAR_VARS)
 LOCAL_SHARED_LIBRARIES := liblog
 LOCAL_SRC_FILES := service_manager.c binder.c
 LOCAL_MODULE := servicemanager
+ifeq ($(BOARD_USE_YAMAHAPLAYER),true)
+    LOCAL_CFLAGS += -DYAMAHAPLAYER
+endif
+ifeq ($(BOARD_USE_SECTVOUT),true)
+    LOCAL_CFLAGS += -DSECTVOUT
+endif
 include $(BUILD_EXECUTABLE)
diff --git a/frameworks/native/cmds/servicemanager/service_manager.c b/frameworks/native/cmds/servicemanager/service_manager.c
index 3eaf1eb..1aa2ade 100644
--- a/frameworks/native/cmds/servicemanager/service_manager.c
+++ b/frameworks/native/cmds/servicemanager/service_manager.c
@@ -32,6 +32,13 @@ static struct {
     { AID_MEDIA, "media.player" },
     { AID_MEDIA, "media.camera" },
     { AID_MEDIA, "media.audio_policy" },
+    { AID_MEDIA, "media.nvidia.audio_alsa" },
+#ifdef YAMAHAPLAYER
+    { AID_MEDIA, "media.yamahaplayer" },
+#endif
+#ifdef SECTVOUT
+    { AID_MEDIA, "SecTVOutService" },
+#endif
     { AID_DRM,   "drm.drmManager" },
     { AID_NFC,   "nfc" },
     { AID_BLUETOOTH, "bluetooth" },
@@ -45,9 +52,14 @@ static struct {
     { AID_RADIO, "isms" },
     { AID_RADIO, "iphonesubinfo" },
     { AID_RADIO, "simphonebook" },
+    { AID_RADIO, "phone_msim" },
+    { AID_RADIO, "isms_msim" },
+    { AID_RADIO, "iphonesubinfo_msim" },
+    { AID_RADIO, "simphonebook_msim" },
     { AID_MEDIA, "common_time.clock" },
     { AID_MEDIA, "common_time.config" },
     { AID_KEYSTORE, "android.security.keystore" },
+    { AID_MEDIA, "listen.service" }
 };
 
 void *svcmgr_handle;
diff --git a/frameworks/native/include/android/input.h b/frameworks/native/include/android/input.h
index fead769..51bb17c 100644
--- a/frameworks/native/include/android/input.h
+++ b/frameworks/native/include/android/input.h
@@ -448,6 +448,7 @@ enum {
     AINPUT_SOURCE_TRACKBALL = 0x00010000 | AINPUT_SOURCE_CLASS_NAVIGATION,
     AINPUT_SOURCE_TOUCHPAD = 0x00100000 | AINPUT_SOURCE_CLASS_POSITION,
     AINPUT_SOURCE_TOUCH_NAVIGATION = 0x00200000 | AINPUT_SOURCE_CLASS_NONE,
+    AINPUT_SOURCE_GESTURE_SENSOR = 0x00400000 | AINPUT_SOURCE_CLASS_NONE,
     AINPUT_SOURCE_JOYSTICK = 0x01000000 | AINPUT_SOURCE_CLASS_JOYSTICK,
 
     AINPUT_SOURCE_ANY = 0xffffff00,
diff --git a/frameworks/native/include/batteryservice/BatteryService.h b/frameworks/native/include/batteryservice/BatteryService.h
index 829061a..105229d 100644
--- a/frameworks/native/include/batteryservice/BatteryService.h
+++ b/frameworks/native/include/batteryservice/BatteryService.h
@@ -47,6 +47,7 @@ struct BatteryProperties {
     bool chargerAcOnline;
     bool chargerUsbOnline;
     bool chargerWirelessOnline;
+
     int batteryStatus;
     int batteryHealth;
     bool batteryPresent;
@@ -57,6 +58,18 @@ struct BatteryProperties {
     int batteryTemperature;
     String8 batteryTechnology;
 
+    bool chargerDockAcOnline;
+    bool dockBatterySupported;
+    int dockBatteryStatus;
+    int dockBatteryHealth;
+    bool dockBatteryPresent;
+    int dockBatteryLevel;
+    int dockBatteryVoltage;
+    int dockBatteryCurrentNow;
+    int dockBatteryChargeCounter;
+    int dockBatteryTemperature;
+    String8 dockBatteryTechnology;
+
     status_t writeToParcel(Parcel* parcel) const;
     status_t readFromParcel(Parcel* parcel);
 };
diff --git a/frameworks/native/include/binder/IMemory.h b/frameworks/native/include/binder/IMemory.h
index 2d0db00..62ac9e3 100644
--- a/frameworks/native/include/binder/IMemory.h
+++ b/frameworks/native/include/binder/IMemory.h
@@ -36,7 +36,8 @@ public:
 
     // flags returned by getFlags()
     enum {
-        READ_ONLY   = 0x00000001
+        READ_ONLY   = 0x00000001,
+        USE_ION_FD  = 0x00000008
     };
 
     virtual int         getHeapID() const = 0;
diff --git a/frameworks/native/include/binder/Parcel.h b/frameworks/native/include/binder/Parcel.h
index 0345a09..41902e1 100644
--- a/frameworks/native/include/binder/Parcel.h
+++ b/frameworks/native/include/binder/Parcel.h
@@ -102,7 +102,6 @@ public:
     status_t            writeStrongBinder(const sp<IBinder>& val);
     status_t            writeWeakBinder(const wp<IBinder>& val);
     status_t            writeInt32Array(size_t len, const int32_t *val);
-
     status_t            write(const Flattenable& val);
 
     template<typename T>
@@ -158,7 +157,6 @@ public:
     const char16_t*     readString16Inplace(size_t* outLen) const;
     sp<IBinder>         readStrongBinder() const;
     wp<IBinder>         readWeakBinder() const;
-
     status_t            read(Flattenable& val) const;
 
     template<typename T>
diff --git a/frameworks/native/include/binder/Parcel.h.orig b/frameworks/native/include/binder/Parcel.h.orig
deleted file mode 100644
index c95f297..0000000
--- a/frameworks/native/include/binder/Parcel.h.orig
+++ /dev/null
@@ -1,396 +0,0 @@
-/*
- * Copyright (C) 2005 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef ANDROID_PARCEL_H
-#define ANDROID_PARCEL_H
-
-#include <cutils/native_handle.h>
-#include <utils/Errors.h>
-#include <utils/RefBase.h>
-#include <utils/String16.h>
-#include <utils/Vector.h>
-#include <utils/Flattenable.h>
-
-// ---------------------------------------------------------------------------
-namespace android {
-
-template <typename T> class Flattenable;
-template <typename T> class LightFlattenable;
-class IBinder;
-class IPCThreadState;
-class ProcessState;
-class String8;
-class TextOutput;
-
-struct flat_binder_object;  // defined in support_p/binder_module.h
-
-class Parcel {
-public:
-    class ReadableBlob;
-    class WritableBlob;
-
-                        Parcel();
-                        ~Parcel();
-    
-    const uint8_t*      data() const;
-    size_t              dataSize() const;
-    size_t              dataAvail() const;
-    size_t              dataPosition() const;
-    size_t              dataCapacity() const;
-
-    status_t            setDataSize(size_t size);
-    void                setDataPosition(size_t pos) const;
-    status_t            setDataCapacity(size_t size);
-    
-    status_t            setData(const uint8_t* buffer, size_t len);
-
-    status_t            appendFrom(const Parcel *parcel,
-                                   size_t start, size_t len);
-
-    bool                pushAllowFds(bool allowFds);
-    void                restoreAllowFds(bool lastValue);
-
-    bool                hasFileDescriptors() const;
-
-    // Writes the RPC header.
-    status_t            writeInterfaceToken(const String16& interface);
-
-    // Parses the RPC header, returning true if the interface name
-    // in the header matches the expected interface from the caller.
-    //
-    // Additionally, enforceInterface does part of the work of
-    // propagating the StrictMode policy mask, populating the current
-    // IPCThreadState, which as an optimization may optionally be
-    // passed in.
-    bool                enforceInterface(const String16& interface,
-                                         IPCThreadState* threadState = NULL) const;
-    bool                checkInterface(IBinder*) const;
-
-    void                freeData();
-
-    const size_t*       objects() const;
-    size_t              objectsCount() const;
-    
-    status_t            errorCheck() const;
-    void                setError(status_t err);
-    
-    status_t            write(const void* data, size_t len);
-    void*               writeInplace(size_t len);
-    status_t            writeUnpadded(const void* data, size_t len);
-    status_t            writeInt32(int32_t val);
-    status_t            writeInt64(int64_t val);
-    status_t            writeFloat(float val);
-    status_t            writeDouble(double val);
-    status_t            writeIntPtr(intptr_t val);
-    status_t            writeCString(const char* str);
-    status_t            writeString8(const String8& str);
-    status_t            writeString16(const String16& str);
-    status_t            writeString16(const char16_t* str, size_t len);
-    status_t            writeStrongBinder(const sp<IBinder>& val);
-    status_t            writeWeakBinder(const wp<IBinder>& val);
-    status_t            writeInt32Array(size_t len, const int32_t *val);
-
-    template<typename T>
-    status_t            write(const Flattenable<T>& val);
-
-    template<typename T>
-    status_t            write(const LightFlattenable<T>& val);
-
-
-    // Place a native_handle into the parcel (the native_handle's file-
-    // descriptors are dup'ed, so it is safe to delete the native_handle
-    // when this function returns). 
-    // Doesn't take ownership of the native_handle.
-    status_t            writeNativeHandle(const native_handle* handle);
-    
-    // Place a file descriptor into the parcel.  The given fd must remain
-    // valid for the lifetime of the parcel.
-    // The Parcel does not take ownership of the given fd unless you ask it to.
-    status_t            writeFileDescriptor(int fd, bool takeOwnership = false);
-    
-    // Place a file descriptor into the parcel.  A dup of the fd is made, which
-    // will be closed once the parcel is destroyed.
-    status_t            writeDupFileDescriptor(int fd);
-
-    // Writes a blob to the parcel.
-    // If the blob is small, then it is stored in-place, otherwise it is
-    // transferred by way of an anonymous shared memory region.
-    // The caller should call release() on the blob after writing its contents.
-    status_t            writeBlob(size_t len, WritableBlob* outBlob);
-
-    status_t            writeObject(const flat_binder_object& val, bool nullMetaData);
-
-    // Like Parcel.java's writeNoException().  Just writes a zero int32.
-    // Currently the native implementation doesn't do any of the StrictMode
-    // stack gathering and serialization that the Java implementation does.
-    status_t            writeNoException();
-
-    void                remove(size_t start, size_t amt);
-    
-    status_t            read(void* outData, size_t len) const;
-    const void*         readInplace(size_t len) const;
-    int32_t             readInt32() const;
-    status_t            readInt32(int32_t *pArg) const;
-    int64_t             readInt64() const;
-    status_t            readInt64(int64_t *pArg) const;
-    float               readFloat() const;
-    status_t            readFloat(float *pArg) const;
-    double              readDouble() const;
-    status_t            readDouble(double *pArg) const;
-    intptr_t            readIntPtr() const;
-    status_t            readIntPtr(intptr_t *pArg) const;
-
-    const char*         readCString() const;
-    String8             readString8() const;
-    String16            readString16() const;
-    const char16_t*     readString16Inplace(size_t* outLen) const;
-    sp<IBinder>         readStrongBinder() const;
-    wp<IBinder>         readWeakBinder() const;
-
-    template<typename T>
-    status_t            read(Flattenable<T>& val) const;
-
-    template<typename T>
-    status_t            read(LightFlattenable<T>& val) const;
-
-    // Like Parcel.java's readExceptionCode().  Reads the first int32
-    // off of a Parcel's header, returning 0 or the negative error
-    // code on exceptions, but also deals with skipping over rich
-    // response headers.  Callers should use this to read & parse the
-    // response headers rather than doing it by hand.
-    int32_t             readExceptionCode() const;
-
-    // Retrieve native_handle from the parcel. This returns a copy of the
-    // parcel's native_handle (the caller takes ownership). The caller
-    // must free the native_handle with native_handle_close() and 
-    // native_handle_delete().
-    native_handle*     readNativeHandle() const;
-
-    
-    // Retrieve a file descriptor from the parcel.  This returns the raw fd
-    // in the parcel, which you do not own -- use dup() to get your own copy.
-    int                 readFileDescriptor() const;
-
-    // Reads a blob from the parcel.
-    // The caller should call release() on the blob after reading its contents.
-    status_t            readBlob(size_t len, ReadableBlob* outBlob) const;
-
-    const flat_binder_object* readObject(bool nullMetaData) const;
-
-    // Explicitly close all file descriptors in the parcel.
-    void                closeFileDescriptors();
-    
-    typedef void        (*release_func)(Parcel* parcel,
-                                        const uint8_t* data, size_t dataSize,
-                                        const size_t* objects, size_t objectsSize,
-                                        void* cookie);
-                        
-    const uint8_t*      ipcData() const;
-    size_t              ipcDataSize() const;
-    const size_t*       ipcObjects() const;
-    size_t              ipcObjectsCount() const;
-    void                ipcSetDataReference(const uint8_t* data, size_t dataSize,
-                                            const size_t* objects, size_t objectsCount,
-                                            release_func relFunc, void* relCookie);
-    
-    void                print(TextOutput& to, uint32_t flags = 0) const;
-
-private:
-                        Parcel(const Parcel& o);
-    Parcel&             operator=(const Parcel& o);
-    
-    status_t            finishWrite(size_t len);
-    void                releaseObjects();
-    void                acquireObjects();
-    status_t            growData(size_t len);
-    status_t            restartWrite(size_t desired);
-    status_t            continueWrite(size_t desired);
-    void                freeDataNoInit();
-    void                initState();
-    void                scanForFds() const;
-                        
-    template<class T>
-    status_t            readAligned(T *pArg) const;
-
-    template<class T>   T readAligned() const;
-
-    template<class T>
-    status_t            writeAligned(T val);
-
-    status_t            mError;
-    uint8_t*            mData;
-    size_t              mDataSize;
-    size_t              mDataCapacity;
-    mutable size_t      mDataPos;
-    size_t*             mObjects;
-    size_t              mObjectsSize;
-    size_t              mObjectsCapacity;
-    mutable size_t      mNextObjectHint;
-
-    mutable bool        mFdsKnown;
-    mutable bool        mHasFds;
-    bool                mAllowFds;
-    
-    release_func        mOwner;
-    void*               mOwnerCookie;
-
-    class Blob {
-    public:
-        Blob();
-        ~Blob();
-
-        void release();
-        inline size_t size() const { return mSize; }
-
-    protected:
-        void init(bool mapped, void* data, size_t size);
-        void clear();
-
-        bool mMapped;
-        void* mData;
-        size_t mSize;
-    };
-
-    class FlattenableHelperInterface {
-    protected:
-        ~FlattenableHelperInterface() { }
-    public:
-        virtual size_t getFlattenedSize() const = 0;
-        virtual size_t getFdCount() const = 0;
-        virtual status_t flatten(void* buffer, size_t size, int* fds, size_t count) const = 0;
-        virtual status_t unflatten(void const* buffer, size_t size, int const* fds, size_t count) = 0;
-    };
-
-    template<typename T>
-    class FlattenableHelper : public FlattenableHelperInterface {
-        friend class Parcel;
-        const Flattenable<T>& val;
-        explicit FlattenableHelper(const Flattenable<T>& val) : val(val) { }
-
-    public:
-        virtual size_t getFlattenedSize() const {
-            return val.getFlattenedSize();
-        }
-        virtual size_t getFdCount() const {
-            return val.getFdCount();
-        }
-        virtual status_t flatten(void* buffer, size_t size, int* fds, size_t count) const {
-            return val.flatten(buffer, size, fds, count);
-        }
-        virtual status_t unflatten(void const* buffer, size_t size, int const* fds, size_t count) {
-            return const_cast<Flattenable<T>&>(val).unflatten(buffer, size, fds, count);
-        }
-    };
-    status_t write(const FlattenableHelperInterface& val);
-    status_t read(FlattenableHelperInterface& val) const;
-
-public:
-    class ReadableBlob : public Blob {
-        friend class Parcel;
-    public:
-        inline const void* data() const { return mData; }
-    };
-
-    class WritableBlob : public Blob {
-        friend class Parcel;
-    public:
-        inline void* data() { return mData; }
-    };
-};
-
-// ---------------------------------------------------------------------------
-
-template<typename T>
-status_t Parcel::write(const Flattenable<T>& val) {
-    const FlattenableHelper<T> helper(val);
-    return write(helper);
-}
-
-template<typename T>
-status_t Parcel::write(const LightFlattenable<T>& val) {
-    size_t size(val.getFlattenedSize());
-    if (!val.isFixedSize()) {
-        status_t err = writeInt32(size);
-        if (err != NO_ERROR) {
-            return err;
-        }
-    }
-    if (size) {
-        void* buffer = writeInplace(size);
-        if (buffer == NULL)
-            return NO_MEMORY;
-        return val.flatten(buffer, size);
-    }
-    return NO_ERROR;
-}
-
-template<typename T>
-status_t Parcel::read(Flattenable<T>& val) const {
-    FlattenableHelper<T> helper(val);
-    return read(helper);
-}
-
-template<typename T>
-status_t Parcel::read(LightFlattenable<T>& val) const {
-    size_t size;
-    if (val.isFixedSize()) {
-        size = val.getFlattenedSize();
-    } else {
-        int32_t s;
-        status_t err = readInt32(&s);
-        if (err != NO_ERROR) {
-            return err;
-        }
-        size = s;
-    }
-    if (size) {
-        void const* buffer = readInplace(size);
-        return buffer == NULL ? NO_MEMORY :
-                val.unflatten(buffer, size);
-    }
-    return NO_ERROR;
-}
-
-// ---------------------------------------------------------------------------
-
-inline TextOutput& operator<<(TextOutput& to, const Parcel& parcel)
-{
-    parcel.print(to);
-    return to;
-}
-
-// ---------------------------------------------------------------------------
-
-// Generic acquire and release of objects.
-void acquire_object(const sp<ProcessState>& proc,
-                    const flat_binder_object& obj, const void* who);
-void release_object(const sp<ProcessState>& proc,
-                    const flat_binder_object& obj, const void* who);
-
-void flatten_binder(const sp<ProcessState>& proc,
-                    const sp<IBinder>& binder, flat_binder_object* out);
-void flatten_binder(const sp<ProcessState>& proc,
-                    const wp<IBinder>& binder, flat_binder_object* out);
-status_t unflatten_binder(const sp<ProcessState>& proc,
-                          const flat_binder_object& flat, sp<IBinder>* out);
-status_t unflatten_binder(const sp<ProcessState>& proc,
-                          const flat_binder_object& flat, wp<IBinder>* out);
-
-}; // namespace android
-
-// ---------------------------------------------------------------------------
-
-#endif // ANDROID_PARCEL_H
diff --git a/frameworks/native/include/gui/BufferQueue.h b/frameworks/native/include/gui/BufferQueue.h
index 84f9e1f..c923e9c 100644
--- a/frameworks/native/include/gui/BufferQueue.h
+++ b/frameworks/native/include/gui/BufferQueue.h
@@ -43,12 +43,12 @@ class BufferQueue : public BnGraphicBufferProducer,
 public:
     enum { MIN_UNDEQUEUED_BUFFERS = 2 };
     enum { NUM_BUFFER_SLOTS = 32 };
-    enum { NO_CONNECTED_API = 0 };
-    enum { INVALID_BUFFER_SLOT = -1 };
-    enum { STALE_BUFFER_SLOT = 1, NO_BUFFER_AVAILABLE, PRESENT_LATER };
 #ifdef STE_HARDWARE
     enum { NUM_BLIT_BUFFER_SLOTS = 2 };
 #endif
+    enum { NO_CONNECTED_API = 0 };
+    enum { INVALID_BUFFER_SLOT = -1 };
+    enum { STALE_BUFFER_SLOT = 1, NO_BUFFER_AVAILABLE, PRESENT_LATER };
 
     // When in async mode we reserve two slots in order to guarantee that the
     // producer and consumer can run asynchronously.
@@ -210,10 +210,17 @@ public:
     // connected to the specified producer API.
     virtual status_t disconnect(int api);
 
+    // setBufferSize enables us to specify user defined sizes for the buffers
+    // that need to be allocated by surfaceflinger for its client. This is
+    // useful for cases where the client doesn't want the gralloc to calculate
+    // buffer size. client should reset this value to 0, if it wants gralloc
+    // to calculate the size for the buffer. this will take effect from next
+    // dequeue buffer.
+    virtual status_t setBuffersSize(int size);
+
     /*
      * IGraphicBufferConsumer interface
      */
-
     // acquireBuffer attempts to acquire ownership of the next pending buffer in
     // the BufferQueue.  If no buffer is pending then it returns -EINVAL.  If a
     // buffer is successfully acquired, the information about the buffer is
diff --git a/frameworks/native/include/gui/GraphicBufferAlloc.h b/frameworks/native/include/gui/GraphicBufferAlloc.h
index b08750c..5a84649 100644
--- a/frameworks/native/include/gui/GraphicBufferAlloc.h
+++ b/frameworks/native/include/gui/GraphicBufferAlloc.h
@@ -35,6 +35,9 @@ public:
     virtual ~GraphicBufferAlloc();
     virtual sp<GraphicBuffer> createGraphicBuffer(uint32_t w, uint32_t h,
         PixelFormat format, uint32_t usage, status_t* error);
+    virtual void setGraphicBufferSize(int size);
+private:
+    int mBufferSize;
 };
 
 
diff --git a/frameworks/native/include/gui/IGraphicBufferAlloc.h b/frameworks/native/include/gui/IGraphicBufferAlloc.h
index cee41d9..fa6296e 100644
--- a/frameworks/native/include/gui/IGraphicBufferAlloc.h
+++ b/frameworks/native/include/gui/IGraphicBufferAlloc.h
@@ -38,6 +38,7 @@ public:
      */
     virtual sp<GraphicBuffer> createGraphicBuffer(uint32_t w, uint32_t h,
             PixelFormat format, uint32_t usage, status_t* error) = 0;
+    virtual void setGraphicBufferSize(int size) = 0;
 };
 
 // ----------------------------------------------------------------------------
diff --git a/frameworks/native/include/gui/IGraphicBufferProducer.h b/frameworks/native/include/gui/IGraphicBufferProducer.h
index 914862b..8f24902 100644
--- a/frameworks/native/include/gui/IGraphicBufferProducer.h
+++ b/frameworks/native/include/gui/IGraphicBufferProducer.h
@@ -203,6 +203,15 @@ public:
     // This method will fail if the the IGraphicBufferProducer is not currently
     // connected to the specified client API.
     virtual status_t disconnect(int api) = 0;
+
+    // setBufferSize enables to specify the user defined size of the buffer
+    // that needs to be allocated by surfaceflinger for its client. This is
+    // useful for cases where the client doesn't want the gralloc to calculate
+    // buffer size. client should reset this value to 0, if it wants gralloc to
+    // calculate the size for the buffer. this will take effect from next
+    // dequeue buffer.
+    virtual status_t setBuffersSize(int size) = 0;
+
 };
 
 // ----------------------------------------------------------------------------
diff --git a/frameworks/native/include/gui/ISurfaceComposer.h b/frameworks/native/include/gui/ISurfaceComposer.h
index 5c3c99c..4264248 100644
--- a/frameworks/native/include/gui/ISurfaceComposer.h
+++ b/frameworks/native/include/gui/ISurfaceComposer.h
@@ -120,7 +120,18 @@ public:
     virtual status_t captureScreen(const sp<IBinder>& display,
             const sp<IGraphicBufferProducer>& producer,
             uint32_t reqWidth, uint32_t reqHeight,
+            uint32_t minLayerZ, uint32_t maxLayerZ,
+            bool isCpuConsumer) = 0;
+
+#ifdef USE_MHEAP_SCREENSHOT
+    /* Capture the specified screen. requires READ_FRAME_BUFFER permission
+     * This function will fail if there is a secure window on screen.
+     */
+    virtual status_t captureScreen(const sp<IBinder>& display, sp<IMemoryHeap>* heap,
+            uint32_t* width, uint32_t* height,
+            uint32_t reqWidth, uint32_t reqHeight,
             uint32_t minLayerZ, uint32_t maxLayerZ) = 0;
+#endif
 };
 
 // ----------------------------------------------------------------------------
@@ -139,6 +150,9 @@ public:
         GET_BUILT_IN_DISPLAY,
         SET_TRANSACTION_STATE,
         AUTHENTICATE_SURFACE,
+#ifdef USE_MHEAP_SCREENSHOT
+        CAPTURE_SCREEN_DEPRECATED,
+#endif
         BLANK,
         UNBLANK,
         GET_DISPLAY_INFO,
diff --git a/frameworks/native/include/gui/Surface.h b/frameworks/native/include/gui/Surface.h
index 6f8a97c..fb27b30 100644
--- a/frameworks/native/include/gui/Surface.h
+++ b/frameworks/native/include/gui/Surface.h
@@ -119,6 +119,7 @@ private:
     int dispatchSetCrop(va_list args);
     int dispatchSetPostTransformCrop(va_list args);
     int dispatchSetUsage(va_list args);
+    int dispatchSetBuffersSize(va_list args);
     int dispatchLock(va_list args);
     int dispatchUnlockAndPost(va_list args);
 
@@ -143,6 +144,7 @@ protected:
     virtual int setBuffersTimestamp(int64_t timestamp);
     virtual int setCrop(Rect const* rect);
     virtual int setUsage(uint32_t reqUsage);
+    virtual int setBuffersSize(int size);
 
 public:
     virtual int lock(ANativeWindow_Buffer* outBuffer, ARect* inOutDirtyBounds);
@@ -191,6 +193,10 @@ private:
     // at the next deuque operation. It is initialized to 0.
     uint32_t mReqUsage;
 
+    // mReqSize is the size of the buffer that will be requested
+    // at the next dequeue operation. It is initialized to 0.
+    uint32_t mReqSize;
+
     // mTimestamp is the timestamp that will be used for the next buffer queue
     // operation. It defaults to NATIVE_WINDOW_TIMESTAMP_AUTO, which means that
     // a timestamp is auto-generated when queueBuffer is called.
@@ -254,6 +260,10 @@ private:
 
     // must be accessed from lock/unlock thread only
     Region mDirtyRegion;
+
+#ifdef SURFACE_SKIP_FIRST_DEQUEUE
+    bool                        mDequeuedOnce;
+#endif
 };
 
 }; // namespace android
diff --git a/frameworks/native/include/gui/SurfaceComposerClient.h b/frameworks/native/include/gui/SurfaceComposerClient.h
index e982bcd..425c111 100644
--- a/frameworks/native/include/gui/SurfaceComposerClient.h
+++ b/frameworks/native/include/gui/SurfaceComposerClient.h
@@ -39,6 +39,9 @@ namespace android {
 
 class DisplayInfo;
 class Composer;
+#ifdef USE_MHEAP_SCREENSHOT
+class IMemoryHeap;
+#endif
 class ISurfaceComposerClient;
 class IGraphicBufferProducer;
 class Region;
@@ -73,6 +76,16 @@ public:
 
     /* triggers screen on and waits for it to complete */
     static void unblankDisplay(const sp<IBinder>& display);
+    // TODO: Remove me.  Do not use.
+    // This is a compatibility shim for one product whose drivers are depending on
+    // this legacy function (when they shouldn't).
+    static status_t getDisplayInfo(int32_t displayId, DisplayInfo* info);
+
+#if defined(ICS_CAMERA_BLOB) || defined(MR0_CAMERA_BLOB)
+    static ssize_t getDisplayWidth(int32_t displayId);
+    static ssize_t getDisplayHeight(int32_t displayId);
+    static ssize_t getDisplayOrientation(int32_t displayId);
+#endif
 
     // ------------------------------------------------------------------------
     // surface creation / destruction
@@ -109,6 +122,8 @@ public:
     //! Close a composer transaction on all active SurfaceComposerClients.
     static void closeGlobalTransaction(bool synchronous = false);
 
+    static int setOrientation(int32_t dpy, int orientation, uint32_t flags);
+
     //! Flag the currently open transaction as an animation transaction.
     static void setAnimationTransaction();
 
@@ -167,6 +182,9 @@ public:
             uint32_t minLayerZ, uint32_t maxLayerZ);
 
 private:
+#ifdef USE_MHEAP_SCREENSHOT
+    sp<IMemoryHeap> mHeap;
+#endif
     mutable sp<CpuConsumer> mCpuConsumer;
     mutable sp<BufferQueue> mBufferQueue;
     CpuConsumer::LockedBuffer mBuffer;
@@ -176,6 +194,10 @@ public:
     ScreenshotClient();
     ~ScreenshotClient();
 
+#if defined(TOROPLUS_RADIO)
+    status_t update();
+#endif
+
     // frees the previous screenshot and capture a new one
     status_t update(const sp<IBinder>& display);
     status_t update(const sp<IBinder>& display,
diff --git a/frameworks/native/include/media/openmax/OMX_Audio.h b/frameworks/native/include/media/openmax/OMX_Audio.h
index 89ce0fc..cbd6ece 100644
--- a/frameworks/native/include/media/openmax/OMX_Audio.h
+++ b/frameworks/native/include/media/openmax/OMX_Audio.h
@@ -13,6 +13,25 @@
  * express or implied.
  * See the License for the specific language governing permissions
  * and limitations under the License.
+ *
+ * This file was modified by Dolby Laboratories, Inc. The portions of the
+ * code that are surrounded by "DOLBY..." are copyrighted and
+ * licensed separately, as follows:
+ *
+ *  (C) 2011-2012 Dolby Laboratories, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
  * -------------------------------------------------------------------
  */
 /*
@@ -107,6 +126,9 @@ typedef enum OMX_AUDIO_CODINGTYPE {
     OMX_AUDIO_CodingRA,          /**< Any variant of RA encoded data */
     OMX_AUDIO_CodingMIDI,        /**< Any variant of MIDI encoded data */
     OMX_AUDIO_CodingFLAC,        /**< Any variant of FLAC encoded data */
+#ifdef DOLBY_UDC
+    OMX_AUDIO_CodingDDP,         /**< Any variant of DDP encoded data */
+#endif // DOLBY_UDC
     OMX_AUDIO_CodingKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */ 
     OMX_AUDIO_CodingVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
     OMX_AUDIO_CodingMax = 0x7FFFFFFF
diff --git a/frameworks/native/include/ui/DisplayInfo.h b/frameworks/native/include/ui/DisplayInfo.h
index 2853e06..5a0905c 100644
--- a/frameworks/native/include/ui/DisplayInfo.h
+++ b/frameworks/native/include/ui/DisplayInfo.h
@@ -34,6 +34,10 @@ struct DisplayInfo {
     uint8_t orientation;
     bool secure;
     uint8_t reserved[2];
+#ifdef HAVE_PIXEL_FORMAT_INFO
+    // TODO: this needs to go away (currently needed only by webkit)
+    PixelFormatInfo pixelFormatInfo;
+#endif
 };
 
 /* Display orientations as defined in Surface.java and ISurfaceComposer.h. */
diff --git a/frameworks/native/include/ui/FramebufferNativeWindow.h b/frameworks/native/include/ui/FramebufferNativeWindow.h
index 5ec738f..02f3c8b 100644
--- a/frameworks/native/include/ui/FramebufferNativeWindow.h
+++ b/frameworks/native/include/ui/FramebufferNativeWindow.h
@@ -31,6 +31,10 @@
 #define MIN_NUM_FRAME_BUFFERS  2
 #define MAX_NUM_FRAME_BUFFERS  3
 
+#ifdef SAMSUNG_HDMI_SUPPORT
+#include "SecHdmiClient.h"
+#endif
+
 extern "C" EGLNativeWindowType android_createDisplaySurface(void);
 
 // ---------------------------------------------------------------------------
@@ -39,6 +43,9 @@ namespace android {
 
 class Surface;
 class NativeBuffer;
+#ifdef SAMSUNG_HDMI_SUPPORT
+class SecHdmiClient;
+#endif
 
 // ---------------------------------------------------------------------------
 
@@ -88,6 +95,9 @@ private:
     int32_t mBufferHead;
     int32_t mCurrentBufferIndex;
     bool mUpdateOnDemand;
+#ifdef SAMSUNG_HDMI_SUPPORT
+    SecHdmiClient *mHdmiClient;
+#endif
 };
     
 // ---------------------------------------------------------------------------
diff --git a/frameworks/native/include/ui/GraphicBuffer.h b/frameworks/native/include/ui/GraphicBuffer.h
index dad0cfc..16994bd 100644
--- a/frameworks/native/include/ui/GraphicBuffer.h
+++ b/frameworks/native/include/ui/GraphicBuffer.h
@@ -53,7 +53,7 @@ public:
         USAGE_SW_READ_RARELY    = GRALLOC_USAGE_SW_READ_RARELY,
         USAGE_SW_READ_OFTEN     = GRALLOC_USAGE_SW_READ_OFTEN,
         USAGE_SW_READ_MASK      = GRALLOC_USAGE_SW_READ_MASK,
-        
+
         USAGE_SW_WRITE_NEVER    = GRALLOC_USAGE_SW_WRITE_NEVER,
         USAGE_SW_WRITE_RARELY   = GRALLOC_USAGE_SW_WRITE_RARELY,
         USAGE_SW_WRITE_OFTEN    = GRALLOC_USAGE_SW_WRITE_OFTEN,
@@ -68,11 +68,18 @@ public:
         USAGE_HW_2D             = GRALLOC_USAGE_HW_2D,
         USAGE_HW_COMPOSER       = GRALLOC_USAGE_HW_COMPOSER,
         USAGE_HW_VIDEO_ENCODER  = GRALLOC_USAGE_HW_VIDEO_ENCODER,
-        USAGE_HW_MASK           = GRALLOC_USAGE_HW_MASK
+        USAGE_HW_MASK           = GRALLOC_USAGE_HW_MASK,
+#ifdef EXYNOS4_ENHANCEMENTS
+        USAGE_HW_FIMC1          = GRALLOC_USAGE_HW_FIMC1
+#endif
     };
 
     GraphicBuffer();
 
+    // creates buffer of bufferSize
+    GraphicBuffer(uint32_t w, uint32_t h,
+                  PixelFormat format, uint32_t usage, uint32_t bufferSize);
+
     // creates w * h buffer
     GraphicBuffer(uint32_t w, uint32_t h, PixelFormat format, uint32_t usage);
 
@@ -92,7 +99,7 @@ public:
     uint32_t getUsage() const           { return usage; }
     PixelFormat getPixelFormat() const  { return format; }
     Rect getBounds() const              { return Rect(width, height); }
-    
+
     status_t reallocate(uint32_t w, uint32_t h, PixelFormat f, uint32_t usage);
 
     status_t lock(uint32_t usage, void** vaddr);
@@ -139,8 +146,10 @@ private:
     GraphicBuffer& operator = (const GraphicBuffer& rhs);
     const GraphicBuffer& operator = (const GraphicBuffer& rhs) const;
 
-    status_t initSize(uint32_t w, uint32_t h, PixelFormat format, 
+    status_t initSize(uint32_t w, uint32_t h, PixelFormat format,
             uint32_t usage);
+    status_t initSize(uint32_t w, uint32_t h, PixelFormat format,
+            uint32_t usage, uint32_t bufferSize);
 
     void free_handle();
 
diff --git a/frameworks/native/include/ui/GraphicBufferAllocator.h b/frameworks/native/include/ui/GraphicBufferAllocator.h
index dffa788..0dbc3aa 100644
--- a/frameworks/native/include/ui/GraphicBufferAllocator.h
+++ b/frameworks/native/include/ui/GraphicBufferAllocator.h
@@ -56,7 +56,10 @@ public:
         USAGE_HW_TEXTURE        = GRALLOC_USAGE_HW_TEXTURE,
         USAGE_HW_RENDER         = GRALLOC_USAGE_HW_RENDER,
         USAGE_HW_2D             = GRALLOC_USAGE_HW_2D,
-        USAGE_HW_MASK           = GRALLOC_USAGE_HW_MASK
+        USAGE_HW_MASK           = GRALLOC_USAGE_HW_MASK,
+#ifdef EXYNOS4_ENHANCEMENTS
+        USAGE_HW_FIMC1          = GRALLOC_USAGE_HW_FIMC1
+#endif
     };
 
     static inline GraphicBufferAllocator& get() { return getInstance(); }
@@ -65,6 +68,9 @@ public:
     status_t alloc(uint32_t w, uint32_t h, PixelFormat format, int usage,
             buffer_handle_t* handle, int32_t* stride);
 
+    status_t alloc(uint32_t w, uint32_t h, PixelFormat format, int usage,
+            buffer_handle_t* handle, int32_t* stride, uint32_t bufferSize);
+
     status_t free(buffer_handle_t handle);
 
     void dump(String8& res) const;
diff --git a/frameworks/native/include/ui/GraphicBufferMapper.h b/frameworks/native/include/ui/GraphicBufferMapper.h
index 99d8723..d304b58 100644
--- a/frameworks/native/include/ui/GraphicBufferMapper.h
+++ b/frameworks/native/include/ui/GraphicBufferMapper.h
@@ -49,7 +49,11 @@ public:
             int usage, const Rect& bounds, android_ycbcr *ycbcr);
 
     status_t unlock(buffer_handle_t handle);
-    
+
+#ifdef EXYNOS4_ENHANCEMENTS
+    status_t getphys(buffer_handle_t handle, void** paddr);
+#endif
+
     // dumps information about the mapping of this handle
     void dump(buffer_handle_t handle);
 
diff --git a/frameworks/native/include/ui/PixelFormat.h b/frameworks/native/include/ui/PixelFormat.h
index 9af1ce6..3c636eb 100644
--- a/frameworks/native/include/ui/PixelFormat.h
+++ b/frameworks/native/include/ui/PixelFormat.h
@@ -74,8 +74,62 @@ enum {
 
 typedef int32_t PixelFormat;
 
+#ifdef HAVE_PIXEL_FORMAT_INFO
+struct PixelFormatInfo {
+    enum {
+        INDEX_ALPHA   = 0,
+        INDEX_RED     = 1,
+        INDEX_GREEN   = 2,
+        INDEX_BLUE    = 3
+    };
+
+    enum { // components
+        ALPHA   = 1,
+        RGB     = 2,
+        RGBA    = 3,
+        L       = 4,
+        LA      = 5,
+        OTHER   = 0xFF
+    };
+
+    struct szinfo {
+        uint8_t h;
+        uint8_t l;
+    };
+
+    inline PixelFormatInfo() : version(sizeof(PixelFormatInfo)) { }
+    size_t getScanlineSize(unsigned int width) const;
+    size_t getSize(size_t ci) const {
+        return (ci <= 3) ? (cinfo[ci].h - cinfo[ci].l) : 0;
+    }
+    size_t      version;
+    PixelFormat format;
+    size_t      bytesPerPixel;
+    size_t      bitsPerPixel;
+    union {
+        szinfo      cinfo[4];
+        struct {
+            uint8_t     h_alpha;
+            uint8_t     l_alpha;
+            uint8_t     h_red;
+            uint8_t     l_red;
+            uint8_t     h_green;
+            uint8_t     l_green;
+            uint8_t     h_blue;
+            uint8_t     l_blue;
+        };
+    };
+    uint8_t     components;
+    uint8_t     reserved0[3];
+    uint32_t    reserved1;
+};
+
+status_t getPixelFormatInfo(PixelFormat format, PixelFormatInfo* info);
+#endif
+
 ssize_t bytesPerPixel(PixelFormat format);
 ssize_t bitsPerPixel(PixelFormat format);
+unsigned int minColorDepth(PixelFormat format);
 
 }; // namespace android
 
diff --git a/frameworks/native/libs/binder/Android.mk b/frameworks/native/libs/binder/Android.mk
index f3f8daf..cb17f78 100644
--- a/frameworks/native/libs/binder/Android.mk
+++ b/frameworks/native/libs/binder/Android.mk
@@ -35,13 +35,28 @@ sources := \
     Static.cpp \
     TextOutput.cpp \
 
+ifeq ($(BOARD_NEEDS_MEMORYHEAPPMEM),true)
+sources += \
+    MemoryHeapPmem.cpp
+endif
+
 LOCAL_PATH:= $(call my-dir)
 
 include $(CLEAR_VARS)
+
+ifeq ($(BOARD_USE_V4L2_ION), true)
+LOCAL_CFLAGS += -DUSE_V4L2_ION
+sources += \
+	MemoryHeapBaseIon.cpp
+LOCAL_C_INCLUDES := hardware/samsung/exynos4/hal/include
+LOCAL_SHARED_LIBRARIES := libsecion
+endif
+
 LOCAL_LDLIBS += -lpthread
 LOCAL_MODULE := libbinder
-LOCAL_SHARED_LIBRARIES := liblog libcutils libutils
+LOCAL_SHARED_LIBRARIES += liblog libcutils libutils
 LOCAL_SRC_FILES := $(sources)
+
 include $(BUILD_SHARED_LIBRARY)
 
 include $(CLEAR_VARS)
@@ -49,4 +64,5 @@ LOCAL_LDLIBS += -lpthread
 LOCAL_MODULE := libbinder
 LOCAL_STATIC_LIBRARIES += libutils
 LOCAL_SRC_FILES := $(sources)
+
 include $(BUILD_STATIC_LIBRARY)
diff --git a/frameworks/native/libs/binder/IMemory.cpp b/frameworks/native/libs/binder/IMemory.cpp
index 07cb41a..54cc735 100644
--- a/frameworks/native/libs/binder/IMemory.cpp
+++ b/frameworks/native/libs/binder/IMemory.cpp
@@ -32,6 +32,10 @@
 #include <binder/Parcel.h>
 #include <utils/CallStack.h>
 
+#ifdef USE_V4L2_ION
+#include "ion.h"
+#endif
+
 #define VERBOSE   0
 
 namespace android {
@@ -299,6 +303,14 @@ void BpMemoryHeap::assertReallyMapped() const
         ALOGE_IF(err, "binder=%p transaction failed fd=%d, size=%ld, err=%d (%s)",
                 asBinder().get(), parcel_fd, size, err, strerror(-err));
 
+#ifdef USE_V4L2_ION
+        int ion_client = -1;
+        if (flags & USE_ION_FD) {
+            ion_client = ion_client_create();
+            ALOGE_IF(ion_client < 0, "BpMemoryHeap : ion client creation error");
+        }
+#endif
+
         int fd = dup( parcel_fd );
         ALOGE_IF(fd==-1, "cannot dup fd=%d, size=%ld, err=%d (%s)",
                 parcel_fd, size, err, strerror(errno));
@@ -311,7 +323,16 @@ void BpMemoryHeap::assertReallyMapped() const
         Mutex::Autolock _l(mLock);
         if (mHeapId == -1) {
             mRealHeap = true;
-            mBase = mmap(0, size, access, MAP_SHARED, fd, offset);
+
+#ifdef USE_V4L2_ION
+        if (flags & USE_ION_FD) {
+            if (ion_client < 0)
+                mBase = MAP_FAILED;
+            else
+                mBase = ion_map(fd, size, offset);
+            } else
+#endif
+                mBase = mmap(0, size, access, MAP_SHARED, fd, offset);
             if (mBase == MAP_FAILED) {
                 ALOGE("cannot map BpMemoryHeap (binder=%p), size=%ld, fd=%d (%s)",
                         asBinder().get(), size, fd, strerror(errno));
@@ -323,6 +344,12 @@ void BpMemoryHeap::assertReallyMapped() const
                 android_atomic_write(fd, &mHeapId);
             }
         }
+#ifdef USE_V4L2_ION
+        if (ion_client < 0)
+            ion_client = -1;
+        else
+            ion_client_destroy(ion_client);
+#endif
     }
 }
 
diff --git a/frameworks/native/libs/binder/IPCThreadState.cpp b/frameworks/native/libs/binder/IPCThreadState.cpp
index 5951a3f..8960ff9 100644
--- a/frameworks/native/libs/binder/IPCThreadState.cpp
+++ b/frameworks/native/libs/binder/IPCThreadState.cpp
@@ -362,6 +362,10 @@ status_t IPCThreadState::clearLastError()
     return err;
 }
 
+extern "C" int _ZN7android14IPCThreadState13getCallingPidEv(IPCThreadState *state) {
+    return state->getCallingPid();
+}
+
 int IPCThreadState::getCallingPid() const
 {
     return mCallingPid;
diff --git a/frameworks/native/libs/binder/MemoryBase.cpp b/frameworks/native/libs/binder/MemoryBase.cpp
index 95ceae4..105c5df 100644
--- a/frameworks/native/libs/binder/MemoryBase.cpp
+++ b/frameworks/native/libs/binder/MemoryBase.cpp
@@ -14,6 +14,7 @@
  * limitations under the License.
  */
 
+#define LOG_TAG "MemoryBase"
 
 #include <stdlib.h>
 #include <stdint.h>
@@ -25,6 +26,10 @@ namespace android {
 
 // ---------------------------------------------------------------------------
 
+#ifdef STE_HARDWARE
+extern "C" void _ZN7android10MemoryBaseC2ERKNS_2spINS_11IMemoryHeapEEElj() __attribute__((alias("_ZN7android10MemoryBaseC1ERKNS_2spINS_11IMemoryHeapEEElj")));
+#endif
+
 MemoryBase::MemoryBase(const sp<IMemoryHeap>& heap,
         ssize_t offset, size_t size)
     : mSize(size), mOffset(offset), mHeap(heap)
@@ -59,3 +64,11 @@ sp<IMemoryHeap> android::MemoryBase::getMemory(long* offset, unsigned int* size)
 
 // ---------------------------------------------------------------------------
 }; // namespace android
+
+// Backwards compatibility for libdatabase_sqlcipher (http://b/8253769).
+extern "C" void _ZN7android10MemoryBaseC1ERKNS_2spINS_11IMemoryHeapEEEij(void*, void*, ssize_t, size_t);
+extern "C" void _ZN7android10MemoryBaseC1ERKNS_2spINS_11IMemoryHeapEEElj(void* obj, void* h, long o, unsigned int size) {
+    _ZN7android10MemoryBaseC1ERKNS_2spINS_11IMemoryHeapEEEij(obj, h, o, size);
+    ALOGW("Using temporary compatibility workaround for usage of MemoryBase "
+          "private API. Please fix your application!");
+}
diff --git a/frameworks/native/libs/binder/MemoryBase.cpp.orig b/frameworks/native/libs/binder/MemoryBase.cpp.orig
deleted file mode 100644
index 033066b..0000000
--- a/frameworks/native/libs/binder/MemoryBase.cpp.orig
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-
-#include <stdlib.h>
-#include <stdint.h>
-
-#include <binder/MemoryBase.h>
-
-
-namespace android {
-
-// ---------------------------------------------------------------------------
-
-MemoryBase::MemoryBase(const sp<IMemoryHeap>& heap,
-        ssize_t offset, size_t size)
-    : mSize(size), mOffset(offset), mHeap(heap)
-{
-}
-
-sp<IMemoryHeap> MemoryBase::getMemory(ssize_t* offset, size_t* size) const
-{
-    if (offset) *offset = mOffset;
-    if (size)   *size = mSize;
-    return mHeap;
-}
-
-MemoryBase::~MemoryBase()
-{
-}
-
-// ---------------------------------------------------------------------------
-}; // namespace android
diff --git a/frameworks/native/libs/binder/Parcel.cpp.orig b/frameworks/native/libs/binder/Parcel.cpp.orig
deleted file mode 100644
index 38e019c..0000000
--- a/frameworks/native/libs/binder/Parcel.cpp.orig
+++ /dev/null
@@ -1,1647 +0,0 @@
-/*
- * Copyright (C) 2005 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "Parcel"
-//#define LOG_NDEBUG 0
-
-#include <binder/Parcel.h>
-
-#include <binder/IPCThreadState.h>
-#include <binder/Binder.h>
-#include <binder/BpBinder.h>
-#include <binder/ProcessState.h>
-#include <binder/TextOutput.h>
-
-#include <utils/Debug.h>
-#include <utils/Log.h>
-#include <utils/String8.h>
-#include <utils/String16.h>
-#include <utils/misc.h>
-#include <utils/Flattenable.h>
-#include <cutils/ashmem.h>
-
-#include <private/binder/binder_module.h>
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <stdint.h>
-#include <sys/mman.h>
-
-#ifndef INT32_MAX
-#define INT32_MAX ((int32_t)(2147483647))
-#endif
-
-#define LOG_REFS(...)
-//#define LOG_REFS(...) ALOG(LOG_DEBUG, "Parcel", __VA_ARGS__)
-
-// ---------------------------------------------------------------------------
-
-#define PAD_SIZE(s) (((s)+3)&~3)
-
-// Note: must be kept in sync with android/os/StrictMode.java's PENALTY_GATHER
-#define STRICT_MODE_PENALTY_GATHER 0x100
-
-// Note: must be kept in sync with android/os/Parcel.java's EX_HAS_REPLY_HEADER
-#define EX_HAS_REPLY_HEADER -128
-
-// Maximum size of a blob to transfer in-place.
-static const size_t IN_PLACE_BLOB_LIMIT = 40 * 1024;
-
-// XXX This can be made public if we want to provide
-// support for typed data.
-struct small_flat_data
-{
-    uint32_t type;
-    uint32_t data;
-};
-
-namespace android {
-
-void acquire_object(const sp<ProcessState>& proc,
-    const flat_binder_object& obj, const void* who)
-{
-    switch (obj.type) {
-        case BINDER_TYPE_BINDER:
-            if (obj.binder) {
-                LOG_REFS("Parcel %p acquiring reference on local %p", who, obj.cookie);
-                static_cast<IBinder*>(obj.cookie)->incStrong(who);
-            }
-            return;
-        case BINDER_TYPE_WEAK_BINDER:
-            if (obj.binder)
-                static_cast<RefBase::weakref_type*>(obj.binder)->incWeak(who);
-            return;
-        case BINDER_TYPE_HANDLE: {
-            const sp<IBinder> b = proc->getStrongProxyForHandle(obj.handle);
-            if (b != NULL) {
-                LOG_REFS("Parcel %p acquiring reference on remote %p", who, b.get());
-                b->incStrong(who);
-            }
-            return;
-        }
-        case BINDER_TYPE_WEAK_HANDLE: {
-            const wp<IBinder> b = proc->getWeakProxyForHandle(obj.handle);
-            if (b != NULL) b.get_refs()->incWeak(who);
-            return;
-        }
-        case BINDER_TYPE_FD: {
-            // intentionally blank -- nothing to do to acquire this, but we do
-            // recognize it as a legitimate object type.
-            return;
-        }
-    }
-
-    ALOGD("Invalid object type 0x%08lx", obj.type);
-}
-
-void release_object(const sp<ProcessState>& proc,
-    const flat_binder_object& obj, const void* who)
-{
-    switch (obj.type) {
-        case BINDER_TYPE_BINDER:
-            if (obj.binder) {
-                LOG_REFS("Parcel %p releasing reference on local %p", who, obj.cookie);
-                static_cast<IBinder*>(obj.cookie)->decStrong(who);
-            }
-            return;
-        case BINDER_TYPE_WEAK_BINDER:
-            if (obj.binder)
-                static_cast<RefBase::weakref_type*>(obj.binder)->decWeak(who);
-            return;
-        case BINDER_TYPE_HANDLE: {
-            const sp<IBinder> b = proc->getStrongProxyForHandle(obj.handle);
-            if (b != NULL) {
-                LOG_REFS("Parcel %p releasing reference on remote %p", who, b.get());
-                b->decStrong(who);
-            }
-            return;
-        }
-        case BINDER_TYPE_WEAK_HANDLE: {
-            const wp<IBinder> b = proc->getWeakProxyForHandle(obj.handle);
-            if (b != NULL) b.get_refs()->decWeak(who);
-            return;
-        }
-        case BINDER_TYPE_FD: {
-            if (obj.cookie != (void*)0) close(obj.handle);
-            return;
-        }
-    }
-
-    ALOGE("Invalid object type 0x%08lx", obj.type);
-}
-
-inline static status_t finish_flatten_binder(
-    const sp<IBinder>& binder, const flat_binder_object& flat, Parcel* out)
-{
-    return out->writeObject(flat, false);
-}
-
-status_t flatten_binder(const sp<ProcessState>& proc,
-    const sp<IBinder>& binder, Parcel* out)
-{
-    flat_binder_object obj;
-    
-    obj.flags = 0x7f | FLAT_BINDER_FLAG_ACCEPTS_FDS;
-    if (binder != NULL) {
-        IBinder *local = binder->localBinder();
-        if (!local) {
-            BpBinder *proxy = binder->remoteBinder();
-            if (proxy == NULL) {
-                ALOGE("null proxy");
-            }
-            const int32_t handle = proxy ? proxy->handle() : 0;
-            obj.type = BINDER_TYPE_HANDLE;
-            obj.handle = handle;
-            obj.cookie = NULL;
-        } else {
-            obj.type = BINDER_TYPE_BINDER;
-            obj.binder = local->getWeakRefs();
-            obj.cookie = local;
-        }
-    } else {
-        obj.type = BINDER_TYPE_BINDER;
-        obj.binder = NULL;
-        obj.cookie = NULL;
-    }
-    
-    return finish_flatten_binder(binder, obj, out);
-}
-
-status_t flatten_binder(const sp<ProcessState>& proc,
-    const wp<IBinder>& binder, Parcel* out)
-{
-    flat_binder_object obj;
-    
-    obj.flags = 0x7f | FLAT_BINDER_FLAG_ACCEPTS_FDS;
-    if (binder != NULL) {
-        sp<IBinder> real = binder.promote();
-        if (real != NULL) {
-            IBinder *local = real->localBinder();
-            if (!local) {
-                BpBinder *proxy = real->remoteBinder();
-                if (proxy == NULL) {
-                    ALOGE("null proxy");
-                }
-                const int32_t handle = proxy ? proxy->handle() : 0;
-                obj.type = BINDER_TYPE_WEAK_HANDLE;
-                obj.handle = handle;
-                obj.cookie = NULL;
-            } else {
-                obj.type = BINDER_TYPE_WEAK_BINDER;
-                obj.binder = binder.get_refs();
-                obj.cookie = binder.unsafe_get();
-            }
-            return finish_flatten_binder(real, obj, out);
-        }
-        
-        // XXX How to deal?  In order to flatten the given binder,
-        // we need to probe it for information, which requires a primary
-        // reference...  but we don't have one.
-        //
-        // The OpenBinder implementation uses a dynamic_cast<> here,
-        // but we can't do that with the different reference counting
-        // implementation we are using.
-        ALOGE("Unable to unflatten Binder weak reference!");
-        obj.type = BINDER_TYPE_BINDER;
-        obj.binder = NULL;
-        obj.cookie = NULL;
-        return finish_flatten_binder(NULL, obj, out);
-    
-    } else {
-        obj.type = BINDER_TYPE_BINDER;
-        obj.binder = NULL;
-        obj.cookie = NULL;
-        return finish_flatten_binder(NULL, obj, out);
-    }
-}
-
-inline static status_t finish_unflatten_binder(
-    BpBinder* proxy, const flat_binder_object& flat, const Parcel& in)
-{
-    return NO_ERROR;
-}
-    
-status_t unflatten_binder(const sp<ProcessState>& proc,
-    const Parcel& in, sp<IBinder>* out)
-{
-    const flat_binder_object* flat = in.readObject(false);
-    
-    if (flat) {
-        switch (flat->type) {
-            case BINDER_TYPE_BINDER:
-                *out = static_cast<IBinder*>(flat->cookie);
-                return finish_unflatten_binder(NULL, *flat, in);
-            case BINDER_TYPE_HANDLE:
-                *out = proc->getStrongProxyForHandle(flat->handle);
-                return finish_unflatten_binder(
-                    static_cast<BpBinder*>(out->get()), *flat, in);
-        }        
-    }
-    return BAD_TYPE;
-}
-
-status_t unflatten_binder(const sp<ProcessState>& proc,
-    const Parcel& in, wp<IBinder>* out)
-{
-    const flat_binder_object* flat = in.readObject(false);
-    
-    if (flat) {
-        switch (flat->type) {
-            case BINDER_TYPE_BINDER:
-                *out = static_cast<IBinder*>(flat->cookie);
-                return finish_unflatten_binder(NULL, *flat, in);
-            case BINDER_TYPE_WEAK_BINDER:
-                if (flat->binder != NULL) {
-                    out->set_object_and_refs(
-                        static_cast<IBinder*>(flat->cookie),
-                        static_cast<RefBase::weakref_type*>(flat->binder));
-                } else {
-                    *out = NULL;
-                }
-                return finish_unflatten_binder(NULL, *flat, in);
-            case BINDER_TYPE_HANDLE:
-            case BINDER_TYPE_WEAK_HANDLE:
-                *out = proc->getWeakProxyForHandle(flat->handle);
-                return finish_unflatten_binder(
-                    static_cast<BpBinder*>(out->unsafe_get()), *flat, in);
-        }
-    }
-    return BAD_TYPE;
-}
-
-// ---------------------------------------------------------------------------
-
-Parcel::Parcel()
-{
-    initState();
-}
-
-Parcel::~Parcel()
-{
-    freeDataNoInit();
-}
-
-const uint8_t* Parcel::data() const
-{
-    return mData;
-}
-
-size_t Parcel::dataSize() const
-{
-    return (mDataSize > mDataPos ? mDataSize : mDataPos);
-}
-
-size_t Parcel::dataAvail() const
-{
-    // TODO: decide what to do about the possibility that this can
-    // report an available-data size that exceeds a Java int's max
-    // positive value, causing havoc.  Fortunately this will only
-    // happen if someone constructs a Parcel containing more than two
-    // gigabytes of data, which on typical phone hardware is simply
-    // not possible.
-    return dataSize() - dataPosition();
-}
-
-size_t Parcel::dataPosition() const
-{
-    return mDataPos;
-}
-
-size_t Parcel::dataCapacity() const
-{
-    return mDataCapacity;
-}
-
-status_t Parcel::setDataSize(size_t size)
-{
-    status_t err;
-    err = continueWrite(size);
-    if (err == NO_ERROR) {
-        mDataSize = size;
-        ALOGV("setDataSize Setting data size of %p to %d\n", this, mDataSize);
-    }
-    return err;
-}
-
-void Parcel::setDataPosition(size_t pos) const
-{
-    mDataPos = pos;
-    mNextObjectHint = 0;
-}
-
-status_t Parcel::setDataCapacity(size_t size)
-{
-    if (size > mDataCapacity) return continueWrite(size);
-    return NO_ERROR;
-}
-
-status_t Parcel::setData(const uint8_t* buffer, size_t len)
-{
-    status_t err = restartWrite(len);
-    if (err == NO_ERROR) {
-        memcpy(const_cast<uint8_t*>(data()), buffer, len);
-        mDataSize = len;
-        mFdsKnown = false;
-    }
-    return err;
-}
-
-status_t Parcel::appendFrom(const Parcel *parcel, size_t offset, size_t len)
-{
-    const sp<ProcessState> proc(ProcessState::self());
-    status_t err;
-    const uint8_t *data = parcel->mData;
-    const size_t *objects = parcel->mObjects;
-    size_t size = parcel->mObjectsSize;
-    int startPos = mDataPos;
-    int firstIndex = -1, lastIndex = -2;
-
-    if (len == 0) {
-        return NO_ERROR;
-    }
-
-    // range checks against the source parcel size
-    if ((offset > parcel->mDataSize)
-            || (len > parcel->mDataSize)
-            || (offset + len > parcel->mDataSize)) {
-        return BAD_VALUE;
-    }
-
-    // Count objects in range
-    for (int i = 0; i < (int) size; i++) {
-        size_t off = objects[i];
-        if ((off >= offset) && (off < offset + len)) {
-            if (firstIndex == -1) {
-                firstIndex = i;
-            }
-            lastIndex = i;
-        }
-    }
-    int numObjects = lastIndex - firstIndex + 1;
-
-    if ((mDataSize+len) > mDataCapacity) {
-        // grow data
-        err = growData(len);
-        if (err != NO_ERROR) {
-            return err;
-        }
-    }
-
-    // append data
-    memcpy(mData + mDataPos, data + offset, len);
-    mDataPos += len;
-    mDataSize += len;
-
-    err = NO_ERROR;
-
-    if (numObjects > 0) {
-        // grow objects
-        if (mObjectsCapacity < mObjectsSize + numObjects) {
-            int newSize = ((mObjectsSize + numObjects)*3)/2;
-            size_t *objects =
-                (size_t*)realloc(mObjects, newSize*sizeof(size_t));
-            if (objects == (size_t*)0) {
-                return NO_MEMORY;
-            }
-            mObjects = objects;
-            mObjectsCapacity = newSize;
-        }
-        
-        // append and acquire objects
-        int idx = mObjectsSize;
-        for (int i = firstIndex; i <= lastIndex; i++) {
-            size_t off = objects[i] - offset + startPos;
-            mObjects[idx++] = off;
-            mObjectsSize++;
-
-            flat_binder_object* flat
-                = reinterpret_cast<flat_binder_object*>(mData + off);
-            acquire_object(proc, *flat, this);
-
-            if (flat->type == BINDER_TYPE_FD) {
-                // If this is a file descriptor, we need to dup it so the
-                // new Parcel now owns its own fd, and can declare that we
-                // officially know we have fds.
-                flat->handle = dup(flat->handle);
-                flat->cookie = (void*)1;
-                mHasFds = mFdsKnown = true;
-                if (!mAllowFds) {
-                    err = FDS_NOT_ALLOWED;
-                }
-            }
-        }
-    }
-
-    return err;
-}
-
-bool Parcel::pushAllowFds(bool allowFds)
-{
-    const bool origValue = mAllowFds;
-    if (!allowFds) {
-        mAllowFds = false;
-    }
-    return origValue;
-}
-
-void Parcel::restoreAllowFds(bool lastValue)
-{
-    mAllowFds = lastValue;
-}
-
-bool Parcel::hasFileDescriptors() const
-{
-    if (!mFdsKnown) {
-        scanForFds();
-    }
-    return mHasFds;
-}
-
-// Write RPC headers.  (previously just the interface token)
-status_t Parcel::writeInterfaceToken(const String16& interface)
-{
-    writeInt32(IPCThreadState::self()->getStrictModePolicy() |
-               STRICT_MODE_PENALTY_GATHER);
-    // currently the interface identification token is just its name as a string
-    return writeString16(interface);
-}
-
-bool Parcel::checkInterface(IBinder* binder) const
-{
-    return enforceInterface(binder->getInterfaceDescriptor());
-}
-
-bool Parcel::enforceInterface(const String16& interface,
-                              IPCThreadState* threadState) const
-{
-    int32_t strictPolicy = readInt32();
-    if (threadState == NULL) {
-        threadState = IPCThreadState::self();
-    }
-    if ((threadState->getLastTransactionBinderFlags() &
-         IBinder::FLAG_ONEWAY) != 0) {
-      // For one-way calls, the callee is running entirely
-      // disconnected from the caller, so disable StrictMode entirely.
-      // Not only does disk/network usage not impact the caller, but
-      // there's no way to commuicate back any violations anyway.
-      threadState->setStrictModePolicy(0);
-    } else {
-      threadState->setStrictModePolicy(strictPolicy);
-    }
-    const String16 str(readString16());
-    if (str == interface) {
-        return true;
-    } else {
-        ALOGW("**** enforceInterface() expected '%s' but read '%s'\n",
-                String8(interface).string(), String8(str).string());
-        return false;
-    }
-}
-
-const size_t* Parcel::objects() const
-{
-    return mObjects;
-}
-
-size_t Parcel::objectsCount() const
-{
-    return mObjectsSize;
-}
-
-status_t Parcel::errorCheck() const
-{
-    return mError;
-}
-
-void Parcel::setError(status_t err)
-{
-    mError = err;
-}
-
-status_t Parcel::finishWrite(size_t len)
-{
-    //printf("Finish write of %d\n", len);
-    mDataPos += len;
-    ALOGV("finishWrite Setting data pos of %p to %d\n", this, mDataPos);
-    if (mDataPos > mDataSize) {
-        mDataSize = mDataPos;
-        ALOGV("finishWrite Setting data size of %p to %d\n", this, mDataSize);
-    }
-    //printf("New pos=%d, size=%d\n", mDataPos, mDataSize);
-    return NO_ERROR;
-}
-
-status_t Parcel::writeUnpadded(const void* data, size_t len)
-{
-    size_t end = mDataPos + len;
-    if (end < mDataPos) {
-        // integer overflow
-        return BAD_VALUE;
-    }
-
-    if (end <= mDataCapacity) {
-restart_write:
-        memcpy(mData+mDataPos, data, len);
-        return finishWrite(len);
-    }
-
-    status_t err = growData(len);
-    if (err == NO_ERROR) goto restart_write;
-    return err;
-}
-
-status_t Parcel::write(const void* data, size_t len)
-{
-    void* const d = writeInplace(len);
-    if (d) {
-        memcpy(d, data, len);
-        return NO_ERROR;
-    }
-    return mError;
-}
-
-void* Parcel::writeInplace(size_t len)
-{
-    const size_t padded = PAD_SIZE(len);
-
-    // sanity check for integer overflow
-    if (mDataPos+padded < mDataPos) {
-        return NULL;
-    }
-
-    if ((mDataPos+padded) <= mDataCapacity) {
-restart_write:
-        //printf("Writing %ld bytes, padded to %ld\n", len, padded);
-        uint8_t* const data = mData+mDataPos;
-
-        // Need to pad at end?
-        if (padded != len) {
-#if BYTE_ORDER == BIG_ENDIAN
-            static const uint32_t mask[4] = {
-                0x00000000, 0xffffff00, 0xffff0000, 0xff000000
-            };
-#endif
-#if BYTE_ORDER == LITTLE_ENDIAN
-            static const uint32_t mask[4] = {
-                0x00000000, 0x00ffffff, 0x0000ffff, 0x000000ff
-            };
-#endif
-            //printf("Applying pad mask: %p to %p\n", (void*)mask[padded-len],
-            //    *reinterpret_cast<void**>(data+padded-4));
-            *reinterpret_cast<uint32_t*>(data+padded-4) &= mask[padded-len];
-        }
-
-        finishWrite(padded);
-        return data;
-    }
-
-    status_t err = growData(padded);
-    if (err == NO_ERROR) goto restart_write;
-    return NULL;
-}
-
-status_t Parcel::writeInt32(int32_t val)
-{
-    return writeAligned(val);
-}
-status_t Parcel::writeInt32Array(size_t len, const int32_t *val) {
-    if (!val) {
-        return writeAligned(-1);
-    }
-    status_t ret = writeAligned(len);
-    if (ret == NO_ERROR) {
-        ret = write(val, len * sizeof(*val));
-    }
-    return ret;
-}
-
-status_t Parcel::writeInt64(int64_t val)
-{
-    return writeAligned(val);
-}
-
-status_t Parcel::writeFloat(float val)
-{
-    return writeAligned(val);
-}
-
-#if defined(__mips__) && defined(__mips_hard_float)
-
-status_t Parcel::writeDouble(double val)
-{
-    union {
-        double d;
-        unsigned long long ll;
-    } u;
-    u.d = val;
-    return writeAligned(u.ll);
-}
-
-#else
-
-status_t Parcel::writeDouble(double val)
-{
-    return writeAligned(val);
-}
-
-#endif
-
-status_t Parcel::writeIntPtr(intptr_t val)
-{
-    return writeAligned(val);
-}
-
-status_t Parcel::writeCString(const char* str)
-{
-    return write(str, strlen(str)+1);
-}
-
-status_t Parcel::writeString8(const String8& str)
-{
-    status_t err = writeInt32(str.bytes());
-    // only write string if its length is more than zero characters,
-    // as readString8 will only read if the length field is non-zero.
-    // this is slightly different from how writeString16 works.
-    if (str.bytes() > 0 && err == NO_ERROR) {
-        err = write(str.string(), str.bytes()+1);
-    }
-    return err;
-}
-
-status_t Parcel::writeString16(const String16& str)
-{
-    return writeString16(str.string(), str.size());
-}
-
-status_t Parcel::writeString16(const char16_t* str, size_t len)
-{
-    if (str == NULL) return writeInt32(-1);
-    
-    status_t err = writeInt32(len);
-    if (err == NO_ERROR) {
-        len *= sizeof(char16_t);
-        uint8_t* data = (uint8_t*)writeInplace(len+sizeof(char16_t));
-        if (data) {
-            memcpy(data, str, len);
-            *reinterpret_cast<char16_t*>(data+len) = 0;
-            return NO_ERROR;
-        }
-        err = mError;
-    }
-    return err;
-}
-
-status_t Parcel::writeStrongBinder(const sp<IBinder>& val)
-{
-    return flatten_binder(ProcessState::self(), val, this);
-}
-
-status_t Parcel::writeWeakBinder(const wp<IBinder>& val)
-{
-    return flatten_binder(ProcessState::self(), val, this);
-}
-
-status_t Parcel::writeNativeHandle(const native_handle* handle)
-{
-    if (!handle || handle->version != sizeof(native_handle))
-        return BAD_TYPE;
-
-    status_t err;
-    err = writeInt32(handle->numFds);
-    if (err != NO_ERROR) return err;
-
-    err = writeInt32(handle->numInts);
-    if (err != NO_ERROR) return err;
-
-    for (int i=0 ; err==NO_ERROR && i<handle->numFds ; i++)
-        err = writeDupFileDescriptor(handle->data[i]);
-
-    if (err != NO_ERROR) {
-        ALOGD("write native handle, write dup fd failed");
-        return err;
-    }
-    err = write(handle->data + handle->numFds, sizeof(int)*handle->numInts);
-    return err;
-}
-
-status_t Parcel::writeFileDescriptor(int fd, bool takeOwnership)
-{
-    flat_binder_object obj;
-    obj.type = BINDER_TYPE_FD;
-    obj.flags = 0x7f | FLAT_BINDER_FLAG_ACCEPTS_FDS;
-    obj.handle = fd;
-    obj.cookie = (void*) (takeOwnership ? 1 : 0);
-    return writeObject(obj, true);
-}
-
-status_t Parcel::writeDupFileDescriptor(int fd)
-{
-    int dupFd = dup(fd);
-    if (dupFd < 0) {
-        return -errno;
-    }
-    status_t err = writeFileDescriptor(dupFd, true /*takeOwnership*/);
-    if (err) {
-        close(dupFd);
-    }
-    return err;
-}
-
-status_t Parcel::writeBlob(size_t len, WritableBlob* outBlob)
-{
-    status_t status;
-
-    if (!mAllowFds || len <= IN_PLACE_BLOB_LIMIT) {
-        ALOGV("writeBlob: write in place");
-        status = writeInt32(0);
-        if (status) return status;
-
-        void* ptr = writeInplace(len);
-        if (!ptr) return NO_MEMORY;
-
-        outBlob->init(false /*mapped*/, ptr, len);
-        return NO_ERROR;
-    }
-
-    ALOGV("writeBlob: write to ashmem");
-    int fd = ashmem_create_region("Parcel Blob", len);
-    if (fd < 0) return NO_MEMORY;
-
-    int result = ashmem_set_prot_region(fd, PROT_READ | PROT_WRITE);
-    if (result < 0) {
-        status = result;
-    } else {
-        void* ptr = ::mmap(NULL, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
-        if (ptr == MAP_FAILED) {
-            status = -errno;
-        } else {
-            result = ashmem_set_prot_region(fd, PROT_READ);
-            if (result < 0) {
-                status = result;
-            } else {
-                status = writeInt32(1);
-                if (!status) {
-                    status = writeFileDescriptor(fd, true /*takeOwnership*/);
-                    if (!status) {
-                        outBlob->init(true /*mapped*/, ptr, len);
-                        return NO_ERROR;
-                    }
-                }
-            }
-        }
-        ::munmap(ptr, len);
-    }
-    ::close(fd);
-    return status;
-}
-
-status_t Parcel::write(const FlattenableHelperInterface& val)
-{
-    status_t err;
-
-    // size if needed
-    const size_t len = val.getFlattenedSize();
-    const size_t fd_count = val.getFdCount();
-
-    err = this->writeInt32(len);
-    if (err) return err;
-
-    err = this->writeInt32(fd_count);
-    if (err) return err;
-
-    // payload
-    void* const buf = this->writeInplace(PAD_SIZE(len));
-    if (buf == NULL)
-        return BAD_VALUE;
-
-    int* fds = NULL;
-    if (fd_count) {
-        fds = new int[fd_count];
-    }
-
-    err = val.flatten(buf, len, fds, fd_count);
-    for (size_t i=0 ; i<fd_count && err==NO_ERROR ; i++) {
-        err = this->writeDupFileDescriptor( fds[i] );
-    }
-
-    if (fd_count) {
-        delete [] fds;
-    }
-
-    return err;
-}
-
-status_t Parcel::writeObject(const flat_binder_object& val, bool nullMetaData)
-{
-    const bool enoughData = (mDataPos+sizeof(val)) <= mDataCapacity;
-    const bool enoughObjects = mObjectsSize < mObjectsCapacity;
-    if (enoughData && enoughObjects) {
-restart_write:
-        *reinterpret_cast<flat_binder_object*>(mData+mDataPos) = val;
-        
-        // Need to write meta-data?
-        if (nullMetaData || val.binder != NULL) {
-            mObjects[mObjectsSize] = mDataPos;
-            acquire_object(ProcessState::self(), val, this);
-            mObjectsSize++;
-        }
-        
-        // remember if it's a file descriptor
-        if (val.type == BINDER_TYPE_FD) {
-            if (!mAllowFds) {
-                return FDS_NOT_ALLOWED;
-            }
-            mHasFds = mFdsKnown = true;
-        }
-
-        return finishWrite(sizeof(flat_binder_object));
-    }
-
-    if (!enoughData) {
-        const status_t err = growData(sizeof(val));
-        if (err != NO_ERROR) return err;
-    }
-    if (!enoughObjects) {
-        size_t newSize = ((mObjectsSize+2)*3)/2;
-        size_t* objects = (size_t*)realloc(mObjects, newSize*sizeof(size_t));
-        if (objects == NULL) return NO_MEMORY;
-        mObjects = objects;
-        mObjectsCapacity = newSize;
-    }
-    
-    goto restart_write;
-}
-
-status_t Parcel::writeNoException()
-{
-    return writeInt32(0);
-}
-
-void Parcel::remove(size_t start, size_t amt)
-{
-    LOG_ALWAYS_FATAL("Parcel::remove() not yet implemented!");
-}
-
-status_t Parcel::read(void* outData, size_t len) const
-{
-    if ((mDataPos+PAD_SIZE(len)) >= mDataPos && (mDataPos+PAD_SIZE(len)) <= mDataSize) {
-        memcpy(outData, mData+mDataPos, len);
-        mDataPos += PAD_SIZE(len);
-        ALOGV("read Setting data pos of %p to %d\n", this, mDataPos);
-        return NO_ERROR;
-    }
-    return NOT_ENOUGH_DATA;
-}
-
-const void* Parcel::readInplace(size_t len) const
-{
-    if ((mDataPos+PAD_SIZE(len)) >= mDataPos && (mDataPos+PAD_SIZE(len)) <= mDataSize) {
-        const void* data = mData+mDataPos;
-        mDataPos += PAD_SIZE(len);
-        ALOGV("readInplace Setting data pos of %p to %d\n", this, mDataPos);
-        return data;
-    }
-    return NULL;
-}
-
-template<class T>
-status_t Parcel::readAligned(T *pArg) const {
-    COMPILE_TIME_ASSERT_FUNCTION_SCOPE(PAD_SIZE(sizeof(T)) == sizeof(T));
-
-    if ((mDataPos+sizeof(T)) <= mDataSize) {
-        const void* data = mData+mDataPos;
-        mDataPos += sizeof(T);
-        *pArg =  *reinterpret_cast<const T*>(data);
-        return NO_ERROR;
-    } else {
-        return NOT_ENOUGH_DATA;
-    }
-}
-
-template<class T>
-T Parcel::readAligned() const {
-    T result;
-    if (readAligned(&result) != NO_ERROR) {
-        result = 0;
-    }
-
-    return result;
-}
-
-template<class T>
-status_t Parcel::writeAligned(T val) {
-    COMPILE_TIME_ASSERT_FUNCTION_SCOPE(PAD_SIZE(sizeof(T)) == sizeof(T));
-
-    if ((mDataPos+sizeof(val)) <= mDataCapacity) {
-restart_write:
-        *reinterpret_cast<T*>(mData+mDataPos) = val;
-        return finishWrite(sizeof(val));
-    }
-
-    status_t err = growData(sizeof(val));
-    if (err == NO_ERROR) goto restart_write;
-    return err;
-}
-
-status_t Parcel::readInt32(int32_t *pArg) const
-{
-    return readAligned(pArg);
-}
-
-int32_t Parcel::readInt32() const
-{
-    return readAligned<int32_t>();
-}
-
-
-status_t Parcel::readInt64(int64_t *pArg) const
-{
-    return readAligned(pArg);
-}
-
-
-int64_t Parcel::readInt64() const
-{
-    return readAligned<int64_t>();
-}
-
-status_t Parcel::readFloat(float *pArg) const
-{
-    return readAligned(pArg);
-}
-
-
-float Parcel::readFloat() const
-{
-    return readAligned<float>();
-}
-
-#if defined(__mips__) && defined(__mips_hard_float)
-
-status_t Parcel::readDouble(double *pArg) const
-{
-    union {
-      double d;
-      unsigned long long ll;
-    } u;
-    status_t status;
-    status = readAligned(&u.ll);
-    *pArg = u.d;
-    return status;
-}
-
-double Parcel::readDouble() const
-{
-    union {
-      double d;
-      unsigned long long ll;
-    } u;
-    u.ll = readAligned<unsigned long long>();
-    return u.d;
-}
-
-#else
-
-status_t Parcel::readDouble(double *pArg) const
-{
-    return readAligned(pArg);
-}
-
-double Parcel::readDouble() const
-{
-    return readAligned<double>();
-}
-
-#endif
-
-status_t Parcel::readIntPtr(intptr_t *pArg) const
-{
-    return readAligned(pArg);
-}
-
-
-intptr_t Parcel::readIntPtr() const
-{
-    return readAligned<intptr_t>();
-}
-
-
-const char* Parcel::readCString() const
-{
-    const size_t avail = mDataSize-mDataPos;
-    if (avail > 0) {
-        const char* str = reinterpret_cast<const char*>(mData+mDataPos);
-        // is the string's trailing NUL within the parcel's valid bounds?
-        const char* eos = reinterpret_cast<const char*>(memchr(str, 0, avail));
-        if (eos) {
-            const size_t len = eos - str;
-            mDataPos += PAD_SIZE(len+1);
-            ALOGV("readCString Setting data pos of %p to %d\n", this, mDataPos);
-            return str;
-        }
-    }
-    return NULL;
-}
-
-String8 Parcel::readString8() const
-{
-    int32_t size = readInt32();
-    // watch for potential int overflow adding 1 for trailing NUL
-    if (size > 0 && size < INT32_MAX) {
-        const char* str = (const char*)readInplace(size+1);
-        if (str) return String8(str, size);
-    }
-    return String8();
-}
-
-String16 Parcel::readString16() const
-{
-    size_t len;
-    const char16_t* str = readString16Inplace(&len);
-    if (str) return String16(str, len);
-    ALOGE("Reading a NULL string not supported here.");
-    return String16();
-}
-
-const char16_t* Parcel::readString16Inplace(size_t* outLen) const
-{
-    int32_t size = readInt32();
-    // watch for potential int overflow from size+1
-    if (size >= 0 && size < INT32_MAX) {
-        *outLen = size;
-        const char16_t* str = (const char16_t*)readInplace((size+1)*sizeof(char16_t));
-        if (str != NULL) {
-            return str;
-        }
-    }
-    *outLen = 0;
-    return NULL;
-}
-
-sp<IBinder> Parcel::readStrongBinder() const
-{
-    sp<IBinder> val;
-    unflatten_binder(ProcessState::self(), *this, &val);
-    return val;
-}
-
-wp<IBinder> Parcel::readWeakBinder() const
-{
-    wp<IBinder> val;
-    unflatten_binder(ProcessState::self(), *this, &val);
-    return val;
-}
-
-int32_t Parcel::readExceptionCode() const
-{
-  int32_t exception_code = readAligned<int32_t>();
-  if (exception_code == EX_HAS_REPLY_HEADER) {
-    int32_t header_start = dataPosition();
-    int32_t header_size = readAligned<int32_t>();
-    // Skip over fat responses headers.  Not used (or propagated) in
-    // native code
-    setDataPosition(header_start + header_size);
-    // And fat response headers are currently only used when there are no
-    // exceptions, so return no error:
-    return 0;
-  }
-  return exception_code;
-}
-
-native_handle* Parcel::readNativeHandle() const
-{
-    int numFds, numInts;
-    status_t err;
-    err = readInt32(&numFds);
-    if (err != NO_ERROR) return 0;
-    err = readInt32(&numInts);
-    if (err != NO_ERROR) return 0;
-
-    native_handle* h = native_handle_create(numFds, numInts);
-    for (int i=0 ; err==NO_ERROR && i<numFds ; i++) {
-        h->data[i] = dup(readFileDescriptor());
-        if (h->data[i] < 0) err = BAD_VALUE;
-    }
-    err = read(h->data + numFds, sizeof(int)*numInts);
-    if (err != NO_ERROR) {
-        native_handle_close(h);
-        native_handle_delete(h);
-        h = 0;
-    }
-    return h;
-}
-
-
-int Parcel::readFileDescriptor() const
-{
-    const flat_binder_object* flat = readObject(true);
-    if (flat) {
-        switch (flat->type) {
-            case BINDER_TYPE_FD:
-                //ALOGI("Returning file descriptor %ld from parcel %p\n", flat->handle, this);
-                return flat->handle;
-        }        
-    }
-    return BAD_TYPE;
-}
-
-status_t Parcel::readBlob(size_t len, ReadableBlob* outBlob) const
-{
-    int32_t useAshmem;
-    status_t status = readInt32(&useAshmem);
-    if (status) return status;
-
-    if (!useAshmem) {
-        ALOGV("readBlob: read in place");
-        const void* ptr = readInplace(len);
-        if (!ptr) return BAD_VALUE;
-
-        outBlob->init(false /*mapped*/, const_cast<void*>(ptr), len);
-        return NO_ERROR;
-    }
-
-    ALOGV("readBlob: read from ashmem");
-    int fd = readFileDescriptor();
-    if (fd == int(BAD_TYPE)) return BAD_VALUE;
-
-    void* ptr = ::mmap(NULL, len, PROT_READ, MAP_SHARED, fd, 0);
-    if (!ptr) return NO_MEMORY;
-
-    outBlob->init(true /*mapped*/, ptr, len);
-    return NO_ERROR;
-}
-
-status_t Parcel::read(FlattenableHelperInterface& val) const
-{
-    // size
-    const size_t len = this->readInt32();
-    const size_t fd_count = this->readInt32();
-
-    // payload
-    void const* const buf = this->readInplace(PAD_SIZE(len));
-    if (buf == NULL)
-        return BAD_VALUE;
-
-    int* fds = NULL;
-    if (fd_count) {
-        fds = new int[fd_count];
-    }
-
-    status_t err = NO_ERROR;
-    for (size_t i=0 ; i<fd_count && err==NO_ERROR ; i++) {
-        fds[i] = dup(this->readFileDescriptor());
-        if (fds[i] < 0) err = BAD_VALUE;
-    }
-
-    if (err == NO_ERROR) {
-        err = val.unflatten(buf, len, fds, fd_count);
-    }
-
-    if (fd_count) {
-        delete [] fds;
-    }
-
-    return err;
-}
-const flat_binder_object* Parcel::readObject(bool nullMetaData) const
-{
-    const size_t DPOS = mDataPos;
-    if ((DPOS+sizeof(flat_binder_object)) <= mDataSize) {
-        const flat_binder_object* obj
-                = reinterpret_cast<const flat_binder_object*>(mData+DPOS);
-        mDataPos = DPOS + sizeof(flat_binder_object);
-        if (!nullMetaData && (obj->cookie == NULL && obj->binder == NULL)) {
-            // When transferring a NULL object, we don't write it into
-            // the object list, so we don't want to check for it when
-            // reading.
-            ALOGV("readObject Setting data pos of %p to %d\n", this, mDataPos);
-            return obj;
-        }
-        
-        // Ensure that this object is valid...
-        size_t* const OBJS = mObjects;
-        const size_t N = mObjectsSize;
-        size_t opos = mNextObjectHint;
-        
-        if (N > 0) {
-            ALOGV("Parcel %p looking for obj at %d, hint=%d\n",
-                 this, DPOS, opos);
-            
-            // Start at the current hint position, looking for an object at
-            // the current data position.
-            if (opos < N) {
-                while (opos < (N-1) && OBJS[opos] < DPOS) {
-                    opos++;
-                }
-            } else {
-                opos = N-1;
-            }
-            if (OBJS[opos] == DPOS) {
-                // Found it!
-                ALOGV("Parcel found obj %d at index %d with forward search",
-                     this, DPOS, opos);
-                mNextObjectHint = opos+1;
-                ALOGV("readObject Setting data pos of %p to %d\n", this, mDataPos);
-                return obj;
-            }
-        
-            // Look backwards for it...
-            while (opos > 0 && OBJS[opos] > DPOS) {
-                opos--;
-            }
-            if (OBJS[opos] == DPOS) {
-                // Found it!
-                ALOGV("Parcel found obj %d at index %d with backward search",
-                     this, DPOS, opos);
-                mNextObjectHint = opos+1;
-                ALOGV("readObject Setting data pos of %p to %d\n", this, mDataPos);
-                return obj;
-            }
-        }
-        ALOGW("Attempt to read object from Parcel %p at offset %d that is not in the object list",
-             this, DPOS);
-    }
-    return NULL;
-}
-
-void Parcel::closeFileDescriptors()
-{
-    size_t i = mObjectsSize;
-    if (i > 0) {
-        //ALOGI("Closing file descriptors for %d objects...", mObjectsSize);
-    }
-    while (i > 0) {
-        i--;
-        const flat_binder_object* flat
-            = reinterpret_cast<flat_binder_object*>(mData+mObjects[i]);
-        if (flat->type == BINDER_TYPE_FD) {
-            //ALOGI("Closing fd: %ld\n", flat->handle);
-            close(flat->handle);
-        }
-    }
-}
-
-const uint8_t* Parcel::ipcData() const
-{
-    return mData;
-}
-
-size_t Parcel::ipcDataSize() const
-{
-    return (mDataSize > mDataPos ? mDataSize : mDataPos);
-}
-
-const size_t* Parcel::ipcObjects() const
-{
-    return mObjects;
-}
-
-size_t Parcel::ipcObjectsCount() const
-{
-    return mObjectsSize;
-}
-
-void Parcel::ipcSetDataReference(const uint8_t* data, size_t dataSize,
-    const size_t* objects, size_t objectsCount, release_func relFunc, void* relCookie)
-{
-    freeDataNoInit();
-    mError = NO_ERROR;
-    mData = const_cast<uint8_t*>(data);
-    mDataSize = mDataCapacity = dataSize;
-    //ALOGI("setDataReference Setting data size of %p to %lu (pid=%d)\n", this, mDataSize, getpid());
-    mDataPos = 0;
-    ALOGV("setDataReference Setting data pos of %p to %d\n", this, mDataPos);
-    mObjects = const_cast<size_t*>(objects);
-    mObjectsSize = mObjectsCapacity = objectsCount;
-    mNextObjectHint = 0;
-    mOwner = relFunc;
-    mOwnerCookie = relCookie;
-    scanForFds();
-}
-
-void Parcel::print(TextOutput& to, uint32_t flags) const
-{
-    to << "Parcel(";
-    
-    if (errorCheck() != NO_ERROR) {
-        const status_t err = errorCheck();
-        to << "Error: " << (void*)err << " \"" << strerror(-err) << "\"";
-    } else if (dataSize() > 0) {
-        const uint8_t* DATA = data();
-        to << indent << HexDump(DATA, dataSize()) << dedent;
-        const size_t* OBJS = objects();
-        const size_t N = objectsCount();
-        for (size_t i=0; i<N; i++) {
-            const flat_binder_object* flat
-                = reinterpret_cast<const flat_binder_object*>(DATA+OBJS[i]);
-            to << endl << "Object #" << i << " @ " << (void*)OBJS[i] << ": "
-                << TypeCode(flat->type & 0x7f7f7f00)
-                << " = " << flat->binder;
-        }
-    } else {
-        to << "NULL";
-    }
-    
-    to << ")";
-}
-
-void Parcel::releaseObjects()
-{
-    const sp<ProcessState> proc(ProcessState::self());
-    size_t i = mObjectsSize;
-    uint8_t* const data = mData;
-    size_t* const objects = mObjects;
-    while (i > 0) {
-        i--;
-        const flat_binder_object* flat
-            = reinterpret_cast<flat_binder_object*>(data+objects[i]);
-        release_object(proc, *flat, this);
-    }
-}
-
-void Parcel::acquireObjects()
-{
-    const sp<ProcessState> proc(ProcessState::self());
-    size_t i = mObjectsSize;
-    uint8_t* const data = mData;
-    size_t* const objects = mObjects;
-    while (i > 0) {
-        i--;
-        const flat_binder_object* flat
-            = reinterpret_cast<flat_binder_object*>(data+objects[i]);
-        acquire_object(proc, *flat, this);
-    }
-}
-
-void Parcel::freeData()
-{
-    freeDataNoInit();
-    initState();
-}
-
-void Parcel::freeDataNoInit()
-{
-    if (mOwner) {
-        //ALOGI("Freeing data ref of %p (pid=%d)\n", this, getpid());
-        mOwner(this, mData, mDataSize, mObjects, mObjectsSize, mOwnerCookie);
-    } else {
-        releaseObjects();
-        if (mData) free(mData);
-        if (mObjects) free(mObjects);
-    }
-}
-
-status_t Parcel::growData(size_t len)
-{
-    size_t newSize = ((mDataSize+len)*3)/2;
-    return (newSize <= mDataSize)
-            ? (status_t) NO_MEMORY
-            : continueWrite(newSize);
-}
-
-status_t Parcel::restartWrite(size_t desired)
-{
-    if (mOwner) {
-        freeData();
-        return continueWrite(desired);
-    }
-    
-    uint8_t* data = (uint8_t*)realloc(mData, desired);
-    if (!data && desired > mDataCapacity) {
-        mError = NO_MEMORY;
-        return NO_MEMORY;
-    }
-    
-    releaseObjects();
-    
-    if (data) {
-        mData = data;
-        mDataCapacity = desired;
-    }
-    
-    mDataSize = mDataPos = 0;
-    ALOGV("restartWrite Setting data size of %p to %d\n", this, mDataSize);
-    ALOGV("restartWrite Setting data pos of %p to %d\n", this, mDataPos);
-        
-    free(mObjects);
-    mObjects = NULL;
-    mObjectsSize = mObjectsCapacity = 0;
-    mNextObjectHint = 0;
-    mHasFds = false;
-    mFdsKnown = true;
-    mAllowFds = true;
-    
-    return NO_ERROR;
-}
-
-status_t Parcel::continueWrite(size_t desired)
-{
-    // If shrinking, first adjust for any objects that appear
-    // after the new data size.
-    size_t objectsSize = mObjectsSize;
-    if (desired < mDataSize) {
-        if (desired == 0) {
-            objectsSize = 0;
-        } else {
-            while (objectsSize > 0) {
-                if (mObjects[objectsSize-1] < desired)
-                    break;
-                objectsSize--;
-            }
-        }
-    }
-    
-    if (mOwner) {
-        // If the size is going to zero, just release the owner's data.
-        if (desired == 0) {
-            freeData();
-            return NO_ERROR;
-        }
-
-        // If there is a different owner, we need to take
-        // posession.
-        uint8_t* data = (uint8_t*)malloc(desired);
-        if (!data) {
-            mError = NO_MEMORY;
-            return NO_MEMORY;
-        }
-        size_t* objects = NULL;
-        
-        if (objectsSize) {
-            objects = (size_t*)malloc(objectsSize*sizeof(size_t));
-            if (!objects) {
-                free(data);
-
-                mError = NO_MEMORY;
-                return NO_MEMORY;
-            }
-
-            // Little hack to only acquire references on objects
-            // we will be keeping.
-            size_t oldObjectsSize = mObjectsSize;
-            mObjectsSize = objectsSize;
-            acquireObjects();
-            mObjectsSize = oldObjectsSize;
-        }
-        
-        if (mData) {
-            memcpy(data, mData, mDataSize < desired ? mDataSize : desired);
-        }
-        if (objects && mObjects) {
-            memcpy(objects, mObjects, objectsSize*sizeof(size_t));
-        }
-        //ALOGI("Freeing data ref of %p (pid=%d)\n", this, getpid());
-        mOwner(this, mData, mDataSize, mObjects, mObjectsSize, mOwnerCookie);
-        mOwner = NULL;
-
-        mData = data;
-        mObjects = objects;
-        mDataSize = (mDataSize < desired) ? mDataSize : desired;
-        ALOGV("continueWrite Setting data size of %p to %d\n", this, mDataSize);
-        mDataCapacity = desired;
-        mObjectsSize = mObjectsCapacity = objectsSize;
-        mNextObjectHint = 0;
-
-    } else if (mData) {
-        if (objectsSize < mObjectsSize) {
-            // Need to release refs on any objects we are dropping.
-            const sp<ProcessState> proc(ProcessState::self());
-            for (size_t i=objectsSize; i<mObjectsSize; i++) {
-                const flat_binder_object* flat
-                    = reinterpret_cast<flat_binder_object*>(mData+mObjects[i]);
-                if (flat->type == BINDER_TYPE_FD) {
-                    // will need to rescan because we may have lopped off the only FDs
-                    mFdsKnown = false;
-                }
-                release_object(proc, *flat, this);
-            }
-            size_t* objects =
-                (size_t*)realloc(mObjects, objectsSize*sizeof(size_t));
-            if (objects) {
-                mObjects = objects;
-            }
-            mObjectsSize = objectsSize;
-            mNextObjectHint = 0;
-        }
-
-        // We own the data, so we can just do a realloc().
-        if (desired > mDataCapacity) {
-            uint8_t* data = (uint8_t*)realloc(mData, desired);
-            if (data) {
-                mData = data;
-                mDataCapacity = desired;
-            } else if (desired > mDataCapacity) {
-                mError = NO_MEMORY;
-                return NO_MEMORY;
-            }
-        } else {
-            if (mDataSize > desired) {
-                mDataSize = desired;
-                ALOGV("continueWrite Setting data size of %p to %d\n", this, mDataSize);
-            }
-            if (mDataPos > desired) {
-                mDataPos = desired;
-                ALOGV("continueWrite Setting data pos of %p to %d\n", this, mDataPos);
-            }
-        }
-        
-    } else {
-        // This is the first data.  Easy!
-        uint8_t* data = (uint8_t*)malloc(desired);
-        if (!data) {
-            mError = NO_MEMORY;
-            return NO_MEMORY;
-        }
-
-        if(!(mDataCapacity == 0 && mObjects == NULL
-             && mObjectsCapacity == 0)) {
-            ALOGE("continueWrite: %d/%p/%d/%d", mDataCapacity, mObjects, mObjectsCapacity, desired);
-        }
-        
-        mData = data;
-        mDataSize = mDataPos = 0;
-        ALOGV("continueWrite Setting data size of %p to %d\n", this, mDataSize);
-        ALOGV("continueWrite Setting data pos of %p to %d\n", this, mDataPos);
-        mDataCapacity = desired;
-    }
-
-    return NO_ERROR;
-}
-
-void Parcel::initState()
-{
-    mError = NO_ERROR;
-    mData = 0;
-    mDataSize = 0;
-    mDataCapacity = 0;
-    mDataPos = 0;
-    ALOGV("initState Setting data size of %p to %d\n", this, mDataSize);
-    ALOGV("initState Setting data pos of %p to %d\n", this, mDataPos);
-    mObjects = NULL;
-    mObjectsSize = 0;
-    mObjectsCapacity = 0;
-    mNextObjectHint = 0;
-    mHasFds = false;
-    mFdsKnown = true;
-    mAllowFds = true;
-    mOwner = NULL;
-}
-
-void Parcel::scanForFds() const
-{
-    bool hasFds = false;
-    for (size_t i=0; i<mObjectsSize; i++) {
-        const flat_binder_object* flat
-            = reinterpret_cast<const flat_binder_object*>(mData + mObjects[i]);
-        if (flat->type == BINDER_TYPE_FD) {
-            hasFds = true;
-            break;
-        }
-    }
-    mHasFds = hasFds;
-    mFdsKnown = true;
-}
-
-// --- Parcel::Blob ---
-
-Parcel::Blob::Blob() :
-        mMapped(false), mData(NULL), mSize(0) {
-}
-
-Parcel::Blob::~Blob() {
-    release();
-}
-
-void Parcel::Blob::release() {
-    if (mMapped && mData) {
-        ::munmap(mData, mSize);
-    }
-    clear();
-}
-
-void Parcel::Blob::init(bool mapped, void* data, size_t size) {
-    mMapped = mapped;
-    mData = data;
-    mSize = size;
-}
-
-void Parcel::Blob::clear() {
-    mMapped = false;
-    mData = NULL;
-    mSize = 0;
-}
-
-}; // namespace android
diff --git a/frameworks/native/libs/gui/Android.mk b/frameworks/native/libs/gui/Android.mk
index 7fa91f0..1714961 100644
--- a/frameworks/native/libs/gui/Android.mk
+++ b/frameworks/native/libs/gui/Android.mk
@@ -45,6 +45,24 @@ LOCAL_SHARED_LIBRARIES += \
        libhardware_legacy
 #endif
 
+# Executed only on QCOM BSPs
+ifeq ($(TARGET_USES_QCOM_BSP),true)
+ifneq ($(TARGET_QCOM_DISPLAY_VARIANT),)
+    LOCAL_C_INCLUDES += hardware/qcom/display-$(TARGET_QCOM_DISPLAY_VARIANT)/libgralloc
+else
+    LOCAL_C_INCLUDES += hardware/qcom/display/$(TARGET_BOARD_PLATFORM)/libgralloc
+endif
+    LOCAL_CFLAGS += -DQCOM_BSP
+endif
+
+ifeq ($(BOARD_EGL_SKIP_FIRST_DEQUEUE),true)
+    LOCAL_CFLAGS += -DSURFACE_SKIP_FIRST_DEQUEUE
+endif
+
+ifeq ($(BOARD_USE_MHEAP_SCREENSHOT),true)
+    LOCAL_CFLAGS += -DUSE_MHEAP_SCREENSHOT
+endif
+
 LOCAL_MODULE:= libgui
 
 ifeq ($(TARGET_BOARD_PLATFORM), tegra)
@@ -53,6 +71,9 @@ endif
 ifeq ($(TARGET_BOARD_PLATFORM), tegra3)
 	LOCAL_CFLAGS += -DDONT_USE_FENCE_SYNC
 endif
+ifeq ($(TARGET_TOROPLUS_RADIO), true)
+	LOCAL_CFLAGS += -DTOROPLUS_RADIO
+endif
 
 include $(BUILD_SHARED_LIBRARY)
 
diff --git a/frameworks/native/libs/gui/BufferQueue.cpp b/frameworks/native/libs/gui/BufferQueue.cpp
index 2aecb67..717db0e 100644
--- a/frameworks/native/libs/gui/BufferQueue.cpp
+++ b/frameworks/native/libs/gui/BufferQueue.cpp
@@ -191,6 +191,13 @@ status_t BufferQueue::setBufferCount(int bufferCount) {
     return NO_ERROR;
 }
 
+status_t BufferQueue::setBuffersSize(int size) {
+    ST_LOGV("setBuffersSize: size=%d", size);
+    Mutex::Autolock lock(mMutex);
+    mGraphicBufferAlloc->setGraphicBufferSize(size);
+    return NO_ERROR;
+}
+
 int BufferQueue::query(int what, int* outValue)
 {
     ATRACE_CALL();
diff --git a/frameworks/native/libs/gui/GLConsumer.cpp b/frameworks/native/libs/gui/GLConsumer.cpp
index 20213ec..e40d47d 100644
--- a/frameworks/native/libs/gui/GLConsumer.cpp
+++ b/frameworks/native/libs/gui/GLConsumer.cpp
@@ -150,9 +150,9 @@ GLConsumer::GLConsumer(const sp<IGraphicBufferConsumer>& bq, uint32_t tex,
         copybit_open(module, &mBlitEngine);
     }
     ALOGE_IF(!mBlitEngine, "\nCannot open copybit mBlitEngine=%p", mBlitEngine);
-
-    sp<ISurfaceComposer> composer(ComposerService::getComposerService());
-    mGraphicBufferAlloc = composer->createGraphicBufferAlloc();
+ 
+   sp<ISurfaceComposer> composer(ComposerService::getComposerService());
+          mGraphicBufferAlloc = composer->createGraphicBufferAlloc();
     if (mGraphicBufferAlloc == 0) {
         ST_LOGE("createGraphicBufferAlloc() failed in SurfaceTexture()");
     }
@@ -374,7 +374,6 @@ status_t GLConsumer::releaseBufferLocked(int buf,
     return err;
 }
 
-
 #ifdef STE_HARDWARE
 bool GLConsumer::stillTracking(int slot,
         const sp<GraphicBuffer> graphicBuffer) {
@@ -429,7 +428,6 @@ status_t GLConsumer::updateAndReleaseLocked(const BufferQueue::BufferItem& item)
         }
         /* test if source and convert buffer size are ok */
         if (mSlots[buf].mGraphicBuffer != NULL && mBlitSlots[mNextBlitSlot] != NULL) {
-
             sp<GraphicBuffer> srcBuf = mSlots[buf].mGraphicBuffer;
             sp<GraphicBuffer> dstBuf = mBlitSlots[mNextBlitSlot];
             if (srcBuf->getWidth() != dstBuf->getWidth() || srcBuf->getHeight() != dstBuf->getHeight()) {
@@ -1259,3 +1257,4 @@ static void mtxMul(float out[16], const float a[16], const float b[16]) {
 }
 
 }; // namespace android
+
diff --git a/frameworks/native/libs/gui/GraphicBufferAlloc.cpp b/frameworks/native/libs/gui/GraphicBufferAlloc.cpp
index b360e81..c289c34 100644
--- a/frameworks/native/libs/gui/GraphicBufferAlloc.cpp
+++ b/frameworks/native/libs/gui/GraphicBufferAlloc.cpp
@@ -26,6 +26,7 @@ namespace android {
 // ----------------------------------------------------------------------------
 
 GraphicBufferAlloc::GraphicBufferAlloc() {
+    mBufferSize = 0;
 }
 
 GraphicBufferAlloc::~GraphicBufferAlloc() {
@@ -33,7 +34,8 @@ GraphicBufferAlloc::~GraphicBufferAlloc() {
 
 sp<GraphicBuffer> GraphicBufferAlloc::createGraphicBuffer(uint32_t w, uint32_t h,
         PixelFormat format, uint32_t usage, status_t* error) {
-    sp<GraphicBuffer> graphicBuffer(new GraphicBuffer(w, h, format, usage));
+    sp<GraphicBuffer> graphicBuffer(new GraphicBuffer(w, h, format,
+                                                      usage, mBufferSize));
     status_t err = graphicBuffer->initCheck();
     *error = err;
     if (err != 0 || graphicBuffer->handle == 0) {
@@ -48,6 +50,10 @@ sp<GraphicBuffer> GraphicBufferAlloc::createGraphicBuffer(uint32_t w, uint32_t h
     return graphicBuffer;
 }
 
+void GraphicBufferAlloc::setGraphicBufferSize(int size) {
+    mBufferSize = size;
+}
+
 // ----------------------------------------------------------------------------
 }; // namespace android
 // ----------------------------------------------------------------------------
diff --git a/frameworks/native/libs/gui/IGraphicBufferAlloc.cpp b/frameworks/native/libs/gui/IGraphicBufferAlloc.cpp
index 139f219..55ef663 100644
--- a/frameworks/native/libs/gui/IGraphicBufferAlloc.cpp
+++ b/frameworks/native/libs/gui/IGraphicBufferAlloc.cpp
@@ -32,6 +32,7 @@ namespace android {
 
 enum {
     CREATE_GRAPHIC_BUFFER = IBinder::FIRST_CALL_TRANSACTION,
+    SET_GRAPHIC_BUFFER_SIZE,
 };
 
 class BpGraphicBufferAlloc : public BpInterface<IGraphicBufferAlloc>
@@ -63,6 +64,14 @@ public:
         *error = result;
         return graphicBuffer;
     }
+
+    virtual void setGraphicBufferSize(int size) {
+        Parcel data, reply;
+        data.writeInterfaceToken(
+                IGraphicBufferAlloc::getInterfaceDescriptor());
+        data.writeInt32(size);
+        remote()->transact(SET_GRAPHIC_BUFFER_SIZE, data, &reply);
+    }
 };
 
 IMPLEMENT_META_INTERFACE(GraphicBufferAlloc, "android.ui.IGraphicBufferAlloc");
@@ -108,6 +117,12 @@ status_t BnGraphicBufferAlloc::onTransact(
             }
             return NO_ERROR;
         } break;
+        case SET_GRAPHIC_BUFFER_SIZE: {
+            CHECK_INTERFACE(IGraphicBufferAlloc, data, reply);
+            int size = data.readInt32();
+            setGraphicBufferSize(size);
+            return NO_ERROR;
+        } break;
         default:
             return BBinder::onTransact(code, data, reply, flags);
     }
diff --git a/frameworks/native/libs/gui/IGraphicBufferProducer.cpp b/frameworks/native/libs/gui/IGraphicBufferProducer.cpp
index fc86e60..3cbe6e8 100644
--- a/frameworks/native/libs/gui/IGraphicBufferProducer.cpp
+++ b/frameworks/native/libs/gui/IGraphicBufferProducer.cpp
@@ -37,6 +37,7 @@ enum {
     QUEUE_BUFFER,
     CANCEL_BUFFER,
     QUERY,
+    SET_BUFFERS_SIZE,
     CONNECT,
     DISCONNECT,
 };
@@ -60,7 +61,11 @@ public:
         bool nonNull = reply.readInt32();
         if (nonNull) {
             *buf = new GraphicBuffer();
-            reply.read(**buf);
+            result = reply.read(**buf);
+            if(result != NO_ERROR) {
+                (*buf).clear();
+                return result;
+            }
         }
         result = reply.readInt32();
         return result;
@@ -112,7 +117,12 @@ public:
         if (result != NO_ERROR) {
             return result;
         }
-        memcpy(output, reply.readInplace(sizeof(*output)), sizeof(*output));
+        const void *out_data =reply.readInplace(sizeof(*output));
+        if(out_data != NULL) {
+            memcpy(output, out_data, sizeof(*output));
+        } else {
+            return BAD_VALUE;
+        }
         result = reply.readInt32();
         return result;
     }
@@ -149,7 +159,12 @@ public:
         if (result != NO_ERROR) {
             return result;
         }
-        memcpy(output, reply.readInplace(sizeof(*output)), sizeof(*output));
+        const void *out_data =reply.readInplace(sizeof(*output));
+        if(out_data != NULL) {
+            memcpy(output, out_data, sizeof(*output));
+        } else {
+            return BAD_VALUE;
+        }
         result = reply.readInt32();
         return result;
     }
@@ -165,6 +180,19 @@ public:
         result = reply.readInt32();
         return result;
     }
+
+    virtual status_t setBuffersSize(int size) {
+        Parcel data, reply;
+        data.writeInterfaceToken(IGraphicBufferProducer::getInterfaceDescriptor());
+        data.writeInt32(size);
+        status_t result = remote()->transact(SET_BUFFERS_SIZE, data, &reply);
+        if (result != NO_ERROR) {
+            return result;
+        }
+        result = reply.readInt32();
+        return result;
+    }
+
 };
 
 IMPLEMENT_META_INTERFACE(GraphicBufferProducer, "android.gui.IGraphicBufferProducer");
@@ -240,6 +268,13 @@ status_t BnGraphicBufferProducer::onTransact(
             reply->writeInt32(res);
             return NO_ERROR;
         } break;
+        case SET_BUFFERS_SIZE: {
+            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
+            int size = data.readInt32();
+            status_t res = setBuffersSize(size);
+            reply->writeInt32(res);
+            return NO_ERROR;
+        } break;
         case CONNECT: {
             CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
             sp<IBinder> token = data.readStrongBinder();
diff --git a/frameworks/native/libs/gui/ISurfaceComposer.cpp b/frameworks/native/libs/gui/ISurfaceComposer.cpp
index aab0604..ccde018 100644
--- a/frameworks/native/libs/gui/ISurfaceComposer.cpp
+++ b/frameworks/native/libs/gui/ISurfaceComposer.cpp
@@ -102,10 +102,33 @@ public:
         remote()->transact(BnSurfaceComposer::BOOT_FINISHED, data, &reply);
     }
 
+#ifdef USE_MHEAP_SCREENSHOT
+    virtual status_t captureScreen(
+            const sp<IBinder>& display, sp<IMemoryHeap>* heap,
+            uint32_t* width, uint32_t* height,
+            uint32_t reqWidth, uint32_t reqHeight,
+            uint32_t minLayerZ, uint32_t maxLayerZ)
+    {
+        Parcel data, reply;
+        data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());
+        data.writeStrongBinder(display);
+        data.writeInt32(reqWidth);
+        data.writeInt32(reqHeight);
+        data.writeInt32(minLayerZ);
+        data.writeInt32(maxLayerZ);
+        remote()->transact(BnSurfaceComposer::CAPTURE_SCREEN_DEPRECATED, data, &reply);
+        *heap = interface_cast<IMemoryHeap>(reply.readStrongBinder());
+        *width = reply.readInt32();
+        *height = reply.readInt32();
+        return reply.readInt32();
+    }
+#endif
+
     virtual status_t captureScreen(const sp<IBinder>& display,
             const sp<IGraphicBufferProducer>& producer,
             uint32_t reqWidth, uint32_t reqHeight,
-            uint32_t minLayerZ, uint32_t maxLayerZ)
+            uint32_t minLayerZ, uint32_t maxLayerZ,
+            bool isCpuConsumer)
     {
         Parcel data, reply;
         data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());
@@ -115,6 +138,7 @@ public:
         data.writeInt32(reqHeight);
         data.writeInt32(minLayerZ);
         data.writeInt32(maxLayerZ);
+        data.writeInt32(isCpuConsumer);
         remote()->transact(BnSurfaceComposer::CAPTURE_SCREEN, data, &reply);
         return reply.readInt32();
     }
@@ -276,6 +300,25 @@ status_t BnSurfaceComposer::onTransact(
             bootFinished();
             return NO_ERROR;
         }
+#ifdef USE_MHEAP_SCREENSHOT
+        case CAPTURE_SCREEN_DEPRECATED: {
+            CHECK_INTERFACE(ISurfaceComposer, data, reply);
+            sp<IBinder> display = data.readStrongBinder();
+            uint32_t reqWidth = data.readInt32();
+            uint32_t reqHeight = data.readInt32();
+            uint32_t minLayerZ = data.readInt32();
+            uint32_t maxLayerZ = data.readInt32();
+            sp<IMemoryHeap> heap;
+            uint32_t w, h;
+            status_t res = captureScreen(display, &heap, &w, &h,
+                    reqWidth, reqHeight, minLayerZ, maxLayerZ);
+            reply->writeStrongBinder(heap->asBinder());
+            reply->writeInt32(w);
+            reply->writeInt32(h);
+            reply->writeInt32(res);
+            return NO_ERROR;
+        }
+#endif
         case CAPTURE_SCREEN: {
             CHECK_INTERFACE(ISurfaceComposer, data, reply);
             sp<IBinder> display = data.readStrongBinder();
@@ -285,8 +328,10 @@ status_t BnSurfaceComposer::onTransact(
             uint32_t reqHeight = data.readInt32();
             uint32_t minLayerZ = data.readInt32();
             uint32_t maxLayerZ = data.readInt32();
+            bool isCpuConsumer = data.readInt32();
             status_t res = captureScreen(display, producer,
-                    reqWidth, reqHeight, minLayerZ, maxLayerZ);
+                    reqWidth, reqHeight, minLayerZ, maxLayerZ,
+                    isCpuConsumer);
             reply->writeInt32(res);
             return NO_ERROR;
         }
diff --git a/frameworks/native/libs/gui/Surface.cpp b/frameworks/native/libs/gui/Surface.cpp
index 27dbc4e..4d54704 100644
--- a/frameworks/native/libs/gui/Surface.cpp
+++ b/frameworks/native/libs/gui/Surface.cpp
@@ -34,6 +34,10 @@
 
 #include <private/gui/ComposerService.h>
 
+#ifdef QCOM_BSP
+#include <gralloc_priv.h>
+#endif
+
 namespace android {
 
 Surface::Surface(
@@ -61,6 +65,7 @@ Surface::Surface(
     mReqHeight = 0;
     mReqFormat = 0;
     mReqUsage = 0;
+    mReqSize = 0;
     mTimestamp = NATIVE_WINDOW_TIMESTAMP_AUTO;
     mCrop.clear();
     mScalingMode = NATIVE_WINDOW_SCALING_MODE_FREEZE;
@@ -74,6 +79,9 @@ Surface::Surface(
     mConnectedToCpu = false;
     mProducerControlledByApp = controlledByApp;
     mSwapIntervalZero = false;
+#ifdef SURFACE_SKIP_FIRST_DEQUEUE
+    mDequeuedOnce = false;
+#endif
 }
 
 Surface::~Surface() {
@@ -112,9 +120,12 @@ int Surface::hook_queueBuffer(ANativeWindow* window,
 int Surface::hook_dequeueBuffer_DEPRECATED(ANativeWindow* window,
         ANativeWindowBuffer** buffer) {
     Surface* c = getSelf(window);
-    ANativeWindowBuffer* buf;
+    ANativeWindowBuffer* buf = NULL;
     int fenceFd = -1;
     int result = c->dequeueBuffer(&buf, &fenceFd);
+
+    if (result != NO_ERROR) return result;
+
     sp<Fence> fence(new Fence(fenceFd));
     int waitResult = fence->waitForever("dequeueBuffer_DEPRECATED");
     if (waitResult != OK) {
@@ -205,10 +216,13 @@ int Surface::dequeueBuffer(android_native_buffer_t** buffer, int* fenceFd) {
         if (result != NO_ERROR) {
             ALOGE("dequeueBuffer: IGraphicBufferProducer::requestBuffer failed: %d", result);
             return result;
+        } else if (gbuf == 0) {
+            ALOGE("dequeueBuffer: Buffer is null return");
+            return INVALID_OPERATION;
         }
     }
 
-    if (fence->isValid()) {
+    if ((fence != NULL) && fence->isValid()) {
         *fenceFd = fence->dup();
         if (*fenceFd == -1) {
             ALOGE("dequeueBuffer: error duping fence: %d", errno);
@@ -221,6 +235,9 @@ int Surface::dequeueBuffer(android_native_buffer_t** buffer, int* fenceFd) {
     }
 
     *buffer = gbuf.get();
+#ifdef SURFACE_SKIP_FIRST_DEQUEUE
+    if (!mDequeuedOnce) mDequeuedOnce = true;
+#endif
     return OK;
 }
 
@@ -311,12 +328,19 @@ int Surface::query(int what, int* value) const {
                 }
                 break;
             case NATIVE_WINDOW_QUEUES_TO_WINDOW_COMPOSER: {
-                sp<ISurfaceComposer> composer(
-                        ComposerService::getComposerService());
-                if (composer->authenticateSurfaceTexture(mGraphicBufferProducer)) {
-                    *value = 1;
-                } else {
+#ifdef SURFACE_SKIP_FIRST_DEQUEUE
+                if (!mDequeuedOnce) {
                     *value = 0;
+                } else
+#endif
+                {
+                    sp<ISurfaceComposer> composer(
+                            ComposerService::getComposerService());
+                    if (composer->authenticateSurfaceTexture(mGraphicBufferProducer)) {
+                        *value = 1;
+                    } else {
+                        *value = 0;
+                    }
                 }
                 return NO_ERROR;
             }
@@ -344,6 +368,16 @@ int Surface::query(int what, int* value) const {
                 }
                 return err;
             }
+            case NATIVE_WINDOW_CONSUMER_USAGE_BITS: {
+                status_t err = NO_ERROR;
+                err = mGraphicBufferProducer->query(what, value);
+                if(err == NO_ERROR) {
+                    *value |= mReqUsage;
+                    return NO_ERROR;
+                } else {
+                    return err;
+                }
+            }
         }
     }
     return mGraphicBufferProducer->query(what, value);
@@ -386,6 +420,9 @@ int Surface::perform(int operation, va_list args)
     case NATIVE_WINDOW_SET_BUFFERS_FORMAT:
         res = dispatchSetBuffersFormat(args);
         break;
+    case NATIVE_WINDOW_SET_BUFFERS_SIZE:
+        res = dispatchSetBuffersSize(args);
+        break;
     case NATIVE_WINDOW_LOCK:
         res = dispatchLock(args);
         break;
@@ -461,6 +498,11 @@ int Surface::dispatchSetBuffersFormat(va_list args) {
     return setBuffersFormat(f);
 }
 
+int Surface::dispatchSetBuffersSize(va_list args) {
+    int size = va_arg(args, int);
+    return setBuffersSize(size);
+}
+
 int Surface::dispatchSetScalingMode(va_list args) {
     int m = va_arg(args, int);
     return setScalingMode(m);
@@ -518,6 +560,7 @@ int Surface::disconnect(int api) {
         mReqWidth = 0;
         mReqHeight = 0;
         mReqUsage = 0;
+        mReqSize = 0;
         mCrop.clear();
         mScalingMode = NATIVE_WINDOW_SCALING_MODE_FREEZE;
         mTransform = 0;
@@ -618,6 +661,22 @@ int Surface::setBuffersFormat(int format)
     return NO_ERROR;
 }
 
+int Surface::setBuffersSize(int size)
+{
+    ATRACE_CALL();
+    ALOGV("Surface::setBuffersSize");
+
+    if (size<0)
+        return BAD_VALUE;
+
+    Mutex::Autolock lock(mMutex);
+    if(mReqSize != (uint32_t)size) {
+        mReqSize = size;
+        mGraphicBufferProducer->setBuffersSize(size);
+    }
+    return NO_ERROR;
+}
+
 int Surface::setScalingMode(int mode)
 {
     ATRACE_CALL();
@@ -731,7 +790,15 @@ status_t Surface::lock(
             return err;
         }
         // we're intending to do software rendering from this point
+        // Do not overwrite the mReqUsage flag which was set by the client
+#ifdef QCOM_BSP
+        setUsage(mReqUsage & GRALLOC_USAGE_PRIVATE_EXTERNAL_ONLY |
+                mReqUsage & GRALLOC_USAGE_PRIVATE_INTERNAL_ONLY |
+                    GRALLOC_USAGE_SW_READ_OFTEN |
+                    GRALLOC_USAGE_SW_WRITE_OFTEN);
+#else
         setUsage(GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN);
+#endif
     }
 
     ANativeWindowBuffer* out;
@@ -760,6 +827,7 @@ status_t Surface::lock(
         }
 
         // figure out if we can copy the frontbuffer back
+        int backBufferSlot(getSlotFromBufferLocked(backBuffer.get()));
         const sp<GraphicBuffer>& frontBuffer(mPostedBuffer);
         const bool canCopyBack = (frontBuffer != 0 &&
                 backBuffer->width  == frontBuffer->width &&
@@ -767,15 +835,19 @@ status_t Surface::lock(
                 backBuffer->format == frontBuffer->format);
 
         if (canCopyBack) {
-            // copy the area that is invalid and not repainted this round
-            const Region copyback(mDirtyRegion.subtract(newDirtyRegion));
+            Mutex::Autolock lock(mMutex);
+            Region oldDirtyRegion;
+            for(int i = 0 ; i < NUM_BUFFER_SLOTS; i++ ) {
+                if(i != backBufferSlot && !mSlots[i].dirtyRegion.isEmpty())
+                    oldDirtyRegion.orSelf(mSlots[i].dirtyRegion);
+            }
+            const Region copyback(oldDirtyRegion.subtract(newDirtyRegion));
             if (!copyback.isEmpty())
                 copyBlt(backBuffer, frontBuffer, copyback);
         } else {
             // if we can't copy-back anything, modify the user's dirty
             // region to make sure they redraw the whole buffer
             newDirtyRegion.set(bounds);
-            mDirtyRegion.clear();
             Mutex::Autolock lock(mMutex);
             for (size_t i=0 ; i<NUM_BUFFER_SLOTS ; i++) {
                 mSlots[i].dirtyRegion.clear();
@@ -785,15 +857,9 @@ status_t Surface::lock(
 
         { // scope for the lock
             Mutex::Autolock lock(mMutex);
-            int backBufferSlot(getSlotFromBufferLocked(backBuffer.get()));
-            if (backBufferSlot >= 0) {
-                Region& dirtyRegion(mSlots[backBufferSlot].dirtyRegion);
-                mDirtyRegion.subtract(dirtyRegion);
-                dirtyRegion = newDirtyRegion;
-            }
+            mSlots[backBufferSlot].dirtyRegion = newDirtyRegion;
         }
 
-        mDirtyRegion.orSelf(newDirtyRegion);
         if (inOutDirtyBounds) {
             *inOutDirtyBounds = newDirtyRegion.getBounds();
         }
diff --git a/frameworks/native/libs/gui/SurfaceComposerClient.cpp b/frameworks/native/libs/gui/SurfaceComposerClient.cpp
index aafc4d2..ba0f64d 100644
--- a/frameworks/native/libs/gui/SurfaceComposerClient.cpp
+++ b/frameworks/native/libs/gui/SurfaceComposerClient.cpp
@@ -421,6 +421,15 @@ void Composer::setDisplayProjection(const sp<IBinder>& token,
     mForceSynchronous = true; // TODO: do we actually still need this?
 }
 
+status_t Composer::setOrientation(int orientation) {
+    sp<ISurfaceComposer> sm(ComposerService::getComposerService());
+    sp<IBinder> token(sm->getBuiltInDisplay(ISurfaceComposer::eDisplayIdMain));
+    DisplayState& s(getDisplayStateLocked(token));
+    s.orientation = orientation;
+    mForceSynchronous = true; // TODO: do we actually still need this?
+    return NO_ERROR;
+}
+
 // ---------------------------------------------------------------------------
 
 SurfaceComposerClient::SurfaceComposerClient()
@@ -469,6 +478,30 @@ void SurfaceComposerClient::dispose() {
     mStatus = NO_INIT;
 }
 
+/* Create ICS/MR0-compatible constructors */
+extern "C" sp<SurfaceControl> _ZN7android21SurfaceComposerClient13createSurfaceERKNS_7String8Ejjij(
+        const String8& name,
+        uint32_t w,
+        uint32_t h,
+        PixelFormat format,
+        uint32_t flags);
+extern "C" sp<SurfaceControl> _ZN7android21SurfaceComposerClient13createSurfaceEijjij(
+        uint32_t display,
+        uint32_t w,
+        uint32_t h,
+        PixelFormat format,
+        uint32_t flags)
+{
+    String8 name;
+    const size_t SIZE = 128;
+    char buffer[SIZE];
+    snprintf(buffer, SIZE, "<pid_%d>", getpid());
+    name.append(buffer);
+
+    return _ZN7android21SurfaceComposerClient13createSurfaceERKNS_7String8Ejjij(name,
+            w, h, format, flags);
+}
+
 sp<SurfaceControl> SurfaceComposerClient::createSurface(
         const String8& name,
         uint32_t w,
@@ -581,6 +614,11 @@ status_t SurfaceComposerClient::setMatrix(const sp<IBinder>& id, float dsdx, flo
     return getComposer().setMatrix(this, id, dsdx, dtdx, dsdy, dtdy);
 }
 
+status_t SurfaceComposerClient::setOrientation(int32_t dpy, int orientation, uint32_t flags)
+{
+    return Composer::getInstance().setOrientation(orientation);
+}
+
 // ----------------------------------------------------------------------------
 
 void SurfaceComposerClient::setDisplaySurface(const sp<IBinder>& token,
@@ -617,8 +655,43 @@ void SurfaceComposerClient::unblankDisplay(const sp<IBinder>& token) {
     ComposerService::getComposerService()->unblank(token);
 }
 
+// TODO: Remove me.  Do not use.
+// This is a compatibility shim for one product whose drivers are depending on
+// this legacy function (when they shouldn't).
+status_t SurfaceComposerClient::getDisplayInfo(
+        int32_t displayId, DisplayInfo* info)
+{
+    return getDisplayInfo(getBuiltInDisplay(displayId), info);
+}
+
+#if defined(ICS_CAMERA_BLOB) || defined(MR0_CAMERA_BLOB)
+ssize_t SurfaceComposerClient::getDisplayWidth(int32_t displayId) {
+    DisplayInfo info;
+    getDisplayInfo(getBuiltInDisplay(displayId), &info);
+    return info.w;
+}
+
+ssize_t SurfaceComposerClient::getDisplayHeight(int32_t displayId) {
+    DisplayInfo info;
+    getDisplayInfo(getBuiltInDisplay(displayId), &info);
+    return info.h;
+}
+
+ssize_t SurfaceComposerClient::getDisplayOrientation(int32_t displayId) {
+    DisplayInfo info;
+    getDisplayInfo(getBuiltInDisplay(displayId), &info);
+    return info.orientation;
+}
+#endif
+
 // ----------------------------------------------------------------------------
 
+#ifndef FORCE_SCREENSHOT_CPU_PATH
+#define SS_CPU_CONSUMER false
+#else
+#define SS_CPU_CONSUMER true
+#endif
+
 status_t ScreenshotClient::capture(
         const sp<IBinder>& display,
         const sp<IGraphicBufferProducer>& producer,
@@ -626,8 +699,17 @@ status_t ScreenshotClient::capture(
         uint32_t minLayerZ, uint32_t maxLayerZ) {
     sp<ISurfaceComposer> s(ComposerService::getComposerService());
     if (s == NULL) return NO_INIT;
+#ifdef USE_MHEAP_SCREENSHOT
+    int format = 0;
+    producer->query(NATIVE_WINDOW_FORMAT,&format);
+    if (format == PIXEL_FORMAT_RGBA_8888) {
+        /* For some reason, this format fails badly */
+        return BAD_VALUE;
+    }
+#endif
     return s->captureScreen(display, producer,
-            reqWidth, reqHeight, minLayerZ, maxLayerZ);
+            reqWidth, reqHeight, minLayerZ, maxLayerZ,
+            SS_CPU_CONSUMER);
 }
 
 ScreenshotClient::ScreenshotClient()
@@ -639,6 +721,13 @@ ScreenshotClient::~ScreenshotClient() {
     ScreenshotClient::release();
 }
 
+#if defined(TOROPLUS_RADIO)
+status_t ScreenshotClient::update() {
+    sp<ISurfaceComposer> sm(ComposerService::getComposerService());
+    return update(sm->getBuiltInDisplay(0));
+}
+#endif
+
 sp<CpuConsumer> ScreenshotClient::getCpuConsumer() const {
     if (mCpuConsumer == NULL) {
         mBufferQueue = new BufferQueue();
@@ -653,6 +742,19 @@ status_t ScreenshotClient::update(const sp<IBinder>& display,
         uint32_t minLayerZ, uint32_t maxLayerZ) {
     sp<ISurfaceComposer> s(ComposerService::getComposerService());
     if (s == NULL) return NO_INIT;
+#ifdef USE_MHEAP_SCREENSHOT
+    int ret = -1;
+    mHeap = 0;
+    ret = s->captureScreen(display, &mHeap,
+            &mBuffer.width, &mBuffer.height, reqWidth, reqHeight,
+            minLayerZ, maxLayerZ);
+    if (ret == NO_ERROR) {
+        mBuffer.format = PIXEL_FORMAT_RGBA_8888;
+        mBuffer.stride = mBuffer.width;
+        mBuffer.data = (uint8_t *)mHeap->getBase();
+    }
+    return ret;
+#else
     sp<CpuConsumer> cpuConsumer = getCpuConsumer();
 
     if (mHaveBuffer) {
@@ -662,7 +764,7 @@ status_t ScreenshotClient::update(const sp<IBinder>& display,
     }
 
     status_t err = s->captureScreen(display, mBufferQueue,
-            reqWidth, reqHeight, minLayerZ, maxLayerZ);
+            reqWidth, reqHeight, minLayerZ, maxLayerZ, true);
 
     if (err == NO_ERROR) {
         err = mCpuConsumer->lockNextBuffer(&mBuffer);
@@ -671,6 +773,7 @@ status_t ScreenshotClient::update(const sp<IBinder>& display,
         }
     }
     return err;
+#endif
 }
 
 status_t ScreenshotClient::update(const sp<IBinder>& display) {
@@ -683,12 +786,16 @@ status_t ScreenshotClient::update(const sp<IBinder>& display,
 }
 
 void ScreenshotClient::release() {
+#ifdef USE_MHEAP_SCREENSHOT
+    mHeap = 0;
+#else
     if (mHaveBuffer) {
         mCpuConsumer->unlockBuffer(mBuffer);
         memset(&mBuffer, 0, sizeof(mBuffer));
         mHaveBuffer = false;
     }
     mCpuConsumer.clear();
+#endif
 }
 
 void const* ScreenshotClient::getPixels() const {
diff --git a/frameworks/native/libs/gui/SurfaceControl.cpp b/frameworks/native/libs/gui/SurfaceControl.cpp
index 16e533c..128dfbf 100644
--- a/frameworks/native/libs/gui/SurfaceControl.cpp
+++ b/frameworks/native/libs/gui/SurfaceControl.cpp
@@ -108,6 +108,12 @@ status_t SurfaceControl::setPosition(float x, float y) {
     const sp<SurfaceComposerClient>& client(mClient);
     return client->setPosition(mHandle, x, y);
 }
+
+extern "C" int _ZN7android14SurfaceControl11setPositionEff(float x, float y);
+extern "C" int _ZN7android14SurfaceControl11setPositionEii(int32_t x, int32_t y) {
+    return _ZN7android14SurfaceControl11setPositionEff((float)x, (float)y);
+}
+
 status_t SurfaceControl::setSize(uint32_t w, uint32_t h) {
     status_t err = validate();
     if (err < 0) return err;
diff --git a/frameworks/native/libs/ui/Android.mk b/frameworks/native/libs/ui/Android.mk
index 008446b..6c2dcd9 100644
--- a/frameworks/native/libs/ui/Android.mk
+++ b/frameworks/native/libs/ui/Android.mk
@@ -37,6 +37,34 @@ ifneq ($(BOARD_FRAMEBUFFER_FORCE_FORMAT),)
 LOCAL_CFLAGS += -DFRAMEBUFFER_FORCE_FORMAT=$(BOARD_FRAMEBUFFER_FORCE_FORMAT)
 endif
 
+ifeq ($(TARGET_SOC),exynos4210)
+    LOCAL_CFLAGS += -DSAMSUNG_EXYNOS4210
+endif
+
+ifeq ($(TARGET_SOC),exynos4x12)
+    LOCAL_CFLAGS += -DSAMSUNG_EXYNOS4x12
+endif
+
+ifeq ($(TARGET_SOC),exynos5250)
+    LOCAL_CFLAGS += -DSAMSUNG_EXYNOS5250
+endif
+
+ifeq ($(BOARD_USES_SAMSUNG_HDMI),true)
+LOCAL_CFLAGS += -DSAMSUNG_HDMI_SUPPORT
+LOCAL_SHARED_LIBRARIES += libhdmiclient
+LOCAL_C_INCLUDES += hardware/samsung/$(TARGET_BOARD_PLATFORM)/libhdmi/libhdmiservice
+LOCAL_C_INCLUDES += hardware/samsung/$(TARGET_BOARD_PLATFORM)/include
+endif
+
+# Executed only on QCOM BSPs
+ifeq ($(TARGET_USES_QCOM_BSP),true)
+    LOCAL_CFLAGS += -DQCOM_BSP
+endif
+
+ifeq ($(BOARD_HAVE_PIXEL_FORMAT_INFO),true)
+LOCAL_CFLAGS += -DHAVE_PIXEL_FORMAT_INFO
+endif
+
 LOCAL_MODULE:= libui
 
 include $(BUILD_SHARED_LIBRARY)
diff --git a/frameworks/native/libs/ui/FramebufferNativeWindow.cpp b/frameworks/native/libs/ui/FramebufferNativeWindow.cpp
index 31a69b2..12c77b8 100644
--- a/frameworks/native/libs/ui/FramebufferNativeWindow.cpp
+++ b/frameworks/native/libs/ui/FramebufferNativeWindow.cpp
@@ -76,6 +76,11 @@ FramebufferNativeWindow::FramebufferNativeWindow()
     : BASE(), fbDev(0), grDev(0), mUpdateOnDemand(false)
 {
     hw_module_t const* module;
+
+#ifdef SAMSUNG_HDMI_SUPPORT
+    mHdmiClient = android::SecHdmiClient::getInstance();
+#endif
+
     if (hw_get_module(GRALLOC_HARDWARE_MODULE_ID, &module) == 0) {
         int stride;
         int err;
@@ -287,6 +292,25 @@ int FramebufferNativeWindow::queueBuffer(ANativeWindow* window,
     self->front = static_cast<NativeBuffer*>(buffer);
     self->mNumFreeBuffers++;
     self->mCondition.broadcast();
+#ifdef SAMSUNG_HDMI_SUPPORT
+#if defined(SAMSUNG_EXYNOS4210) || defined(SAMSUNG_EXYNOS4x12)
+    if (self->mHdmiClient != NULL)
+        self->mHdmiClient->blit2Hdmi(buffer->width, buffer->height,
+                                    HAL_PIXEL_FORMAT_BGRA_8888,
+                                    0, 0, 0,
+                                    0, 0,
+                                    android::SecHdmiClient::HDMI_MODE_UI,
+                                    0);
+#elif defined(SAMSUNG_EXYNOS5250)
+    if (self->mHdmiClient != NULL)
+        self->mHdmiClient->blit2Hdmi(buffer->width, buffer->height,
+                                    HAL_PIXEL_FORMAT_BGRA_8888,
+                                    0, 0, 0,
+                                    0, 0,
+                                    android::SecHdmiClient::HDMI_MODE_MIRROR,
+                                    0);
+#endif
+#endif
     return res;
 }
 
diff --git a/frameworks/native/libs/ui/GraphicBuffer.cpp b/frameworks/native/libs/ui/GraphicBuffer.cpp
index 0ecd3d9..815c903 100644
--- a/frameworks/native/libs/ui/GraphicBuffer.cpp
+++ b/frameworks/native/libs/ui/GraphicBuffer.cpp
@@ -45,21 +45,35 @@ GraphicBuffer::GraphicBuffer()
     handle = NULL;
 }
 
-GraphicBuffer::GraphicBuffer(uint32_t w, uint32_t h, 
+GraphicBuffer::GraphicBuffer(uint32_t w, uint32_t h,
         PixelFormat reqFormat, uint32_t reqUsage)
     : BASE(), mOwner(ownData), mBufferMapper(GraphicBufferMapper::get()),
       mInitCheck(NO_ERROR)
 {
-    width  = 
-    height = 
-    stride = 
-    format = 
+    width  =
+    height =
+    stride =
+    format =
     usage  = 0;
     handle = NULL;
     mInitCheck = initSize(w, h, reqFormat, reqUsage);
 }
 
 GraphicBuffer::GraphicBuffer(uint32_t w, uint32_t h,
+        PixelFormat reqFormat, uint32_t reqUsage, uint32_t bufferSize)
+    : BASE(), mOwner(ownData), mBufferMapper(GraphicBufferMapper::get()),
+      mInitCheck(NO_ERROR)
+{
+    width  =
+    height =
+    stride =
+    format =
+    usage  = 0;
+    handle = NULL;
+    mInitCheck = initSize(w, h, reqFormat, reqUsage, bufferSize);
+}
+
+GraphicBuffer::GraphicBuffer(uint32_t w, uint32_t h,
         PixelFormat inFormat, uint32_t inUsage,
         uint32_t inStride, native_handle_t* inHandle, bool keepOwnership)
     : BASE(), mOwner(keepOwnership ? ownHandle : ownNone),
@@ -153,6 +167,21 @@ status_t GraphicBuffer::initSize(uint32_t w, uint32_t h, PixelFormat format,
     return err;
 }
 
+status_t GraphicBuffer::initSize(uint32_t w, uint32_t h, PixelFormat format,
+                                 uint32_t reqUsage, uint32_t bufferSize)
+{
+    GraphicBufferAllocator& allocator = GraphicBufferAllocator::get();
+    status_t err = allocator.alloc(w, h, format,
+                                   reqUsage, &handle, &stride, bufferSize);
+    if (err == NO_ERROR) {
+        this->width  = w;
+        this->height = h;
+        this->format = format;
+        this->usage  = reqUsage;
+    }
+    return err;
+}
+
 status_t GraphicBuffer::lock(uint32_t usage, void** vaddr)
 {
     const Rect lockBounds(width, height);
@@ -162,10 +191,10 @@ status_t GraphicBuffer::lock(uint32_t usage, void** vaddr)
 
 status_t GraphicBuffer::lock(uint32_t usage, const Rect& rect, void** vaddr)
 {
-    if (rect.left < 0 || rect.right  > this->width || 
+    if (rect.left < 0 || rect.right  > this->width ||
         rect.top  < 0 || rect.bottom > this->height) {
         ALOGE("locking pixels (%d,%d,%d,%d) outside of buffer (w=%d, h=%d)",
-                rect.left, rect.top, rect.right, rect.bottom, 
+                rect.left, rect.top, rect.right, rect.bottom,
                 this->width, this->height);
         return BAD_VALUE;
     }
@@ -231,12 +260,12 @@ status_t GraphicBuffer::flatten(void*& buffer, size_t& size, int*& fds, size_t&
         native_handle_t const* const h = handle;
         memcpy(fds,     h->data,             h->numFds*sizeof(int));
         memcpy(&buf[8], h->data + h->numFds, h->numInts*sizeof(int));
+        fds += handle->numFds;
+        count -= handle->numFds;
     }
 
     buffer = reinterpret_cast<void*>(static_cast<int*>(buffer) + sizeNeeded);
     size -= sizeNeeded;
-    fds += handle->numFds;
-    count -= handle->numFds;
 
     return NO_ERROR;
 }
@@ -282,6 +311,8 @@ status_t GraphicBuffer::unflatten(
     if (handle != 0) {
         status_t err = mBufferMapper.registerBuffer(handle);
         if (err != NO_ERROR) {
+            width = height = stride = format = usage = 0;
+            handle = NULL;
             ALOGE("unflatten: registerBuffer failed: %s (%d)",
                     strerror(-err), err);
             return err;
diff --git a/frameworks/native/libs/ui/GraphicBufferAllocator.cpp b/frameworks/native/libs/ui/GraphicBufferAllocator.cpp
index ff550d9..016692e 100644
--- a/frameworks/native/libs/ui/GraphicBufferAllocator.cpp
+++ b/frameworks/native/libs/ui/GraphicBufferAllocator.cpp
@@ -1,17 +1,17 @@
-/* 
+/*
 **
 ** Copyright 2009, The Android Open Source Project
 **
-** Licensed under the Apache License, Version 2.0 (the "License"); 
-** you may not use this file except in compliance with the License. 
-** You may obtain a copy of the License at 
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
 **
-**     http://www.apache.org/licenses/LICENSE-2.0 
+**     http://www.apache.org/licenses/LICENSE-2.0
 **
-** Unless required by applicable law or agreed to in writing, software 
-** distributed under the License is distributed on an "AS IS" BASIS, 
-** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
-** See the License for the specific language governing permissions and 
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
 ** limitations under the License.
 */
 
@@ -93,6 +93,15 @@ void GraphicBufferAllocator::dumpToSystemLog()
 status_t GraphicBufferAllocator::alloc(uint32_t w, uint32_t h, PixelFormat format,
         int usage, buffer_handle_t* handle, int32_t* stride)
 {
+    status_t err = alloc(w, h, format, usage, handle, stride, 0);
+    return err;
+}
+
+status_t GraphicBufferAllocator::alloc(uint32_t w, uint32_t h,
+                                       PixelFormat format, int usage,
+                                       buffer_handle_t* handle,
+                                       int32_t* stride, uint32_t bufferSize)
+{
     ATRACE_CALL();
     // make sure to not allocate a N x 0 or 0 x N buffer, since this is
     // allowed from an API stand-point allocate a 1x1 buffer instead.
@@ -100,13 +109,32 @@ status_t GraphicBufferAllocator::alloc(uint32_t w, uint32_t h, PixelFormat forma
         w = h = 1;
 
     // we have a h/w allocator and h/w buffer is requested
-    status_t err; 
+    status_t err;
+#ifdef QCOM_BSP
+    if(bufferSize) {
+        err = mAllocDev->allocSize(mAllocDev, w, h,
+                               format, usage, handle, stride, bufferSize);
+    } else {
+        err = mAllocDev->alloc(mAllocDev, w, h, format, usage, handle, stride);
+    }
+    ALOGW_IF(err, "alloc(%u, %u, %d, %08x, %d ...) failed %d (%s)",
+            w, h, format, usage, bufferSize, err, strerror(-err));
+#else
     
-    err = mAllocDev->alloc(mAllocDev, w, h, format, usage, handle, stride);
+#ifdef EXYNOS4_ENHANCEMENTS
+    if ((format == 0x101) || (format == 0x105) || (format == 0x107)) {
+        // 0x101 = HAL_PIXEL_FORMAT_YCbCr_420_P (Samsung-specific pixel format)
+        // 0x105 = HAL_PIXEL_FORMAT_YCbCr_420_SP (Samsung-specific pixel format)
+        // 0x107 = HAL_PIXEL_FORMAT_YCbCr_420_SP_TILED (Samsung-specific pixel format)
+        usage |= GRALLOC_USAGE_HW_FIMC1; // Exynos HWC wants FIMC-friendly memory allocation
+    }
+#endif
 
+    err = mAllocDev->alloc(mAllocDev, w, h, format, usage, handle, stride);
     ALOGW_IF(err, "alloc(%u, %u, %d, %08x, ...) failed %d (%s)",
             w, h, format, usage, err, strerror(-err));
-    
+#endif
+
     if (err == NO_ERROR) {
         Mutex::Autolock _l(sLock);
         KeyedVector<buffer_handle_t, alloc_rec_t>& list(sAllocList);
diff --git a/frameworks/native/libs/ui/GraphicBufferMapper.cpp b/frameworks/native/libs/ui/GraphicBufferMapper.cpp
index a4cfce2..cfbf32c 100644
--- a/frameworks/native/libs/ui/GraphicBufferMapper.cpp
+++ b/frameworks/native/libs/ui/GraphicBufferMapper.cpp
@@ -109,5 +109,18 @@ status_t GraphicBufferMapper::unlock(buffer_handle_t handle)
     return err;
 }
 
+#ifdef EXYNOS4_ENHANCEMENTS
+status_t GraphicBufferMapper::getphys(buffer_handle_t handle, void** paddr)
+{
+    status_t err;
+
+    err = mAllocMod->getphys(mAllocMod, handle, paddr);
+
+    ALOGW_IF(err, "getphys(%p) fail %d(%s)",
+    handle, err, strerror(-err));
+    return err;
+}
+#endif
+
 // ---------------------------------------------------------------------------
 }; // namespace android
diff --git a/frameworks/native/libs/ui/PixelFormat.cpp b/frameworks/native/libs/ui/PixelFormat.cpp
index 68eaa7b..9e9b479 100644
--- a/frameworks/native/libs/ui/PixelFormat.cpp
+++ b/frameworks/native/libs/ui/PixelFormat.cpp
@@ -21,6 +21,129 @@
 namespace android {
 // ----------------------------------------------------------------------------
 
+#ifdef HAVE_PIXEL_FORMAT_INFO
+static const int COMPONENT_YUV = 0xFF;
+
+struct Info {
+    size_t      size;
+    size_t      bitsPerPixel;
+    struct {
+        uint8_t     ah;
+        uint8_t     al;
+        uint8_t     rh;
+        uint8_t     rl;
+        uint8_t     gh;
+        uint8_t     gl;
+        uint8_t     bh;
+        uint8_t     bl;
+    };
+    uint8_t     components;
+};
+
+static Info const sPixelFormatInfos[] = {
+        { 0,  0, { 0, 0,   0, 0,   0, 0,   0, 0 }, 0 },
+        { 4, 32, {32,24,   8, 0,  16, 8,  24,16 }, PixelFormatInfo::RGBA },
+        { 4, 24, { 0, 0,   8, 0,  16, 8,  24,16 }, PixelFormatInfo::RGB  },
+        { 3, 24, { 0, 0,   8, 0,  16, 8,  24,16 }, PixelFormatInfo::RGB  },
+        { 2, 16, { 0, 0,  16,11,  11, 5,   5, 0 }, PixelFormatInfo::RGB  },
+        { 4, 32, {32,24,  24,16,  16, 8,   8, 0 }, PixelFormatInfo::RGBA },
+        { 2, 16, { 1, 0,  16,11,  11, 6,   6, 1 }, PixelFormatInfo::RGBA },
+        { 2, 16, { 4, 0,  16,12,  12, 8,   8, 4 }, PixelFormatInfo::RGBA },
+        { 1,  8, { 8, 0,   0, 0,   0, 0,   0, 0 }, PixelFormatInfo::ALPHA},
+        { 1,  8, { 0, 0,   8, 0,   8, 0,   8, 0 }, PixelFormatInfo::L    },
+        { 2, 16, {16, 8,   8, 0,   8, 0,   8, 0 }, PixelFormatInfo::LA   },
+        { 1,  8, { 0, 0,   8, 5,   5, 2,   2, 0 }, PixelFormatInfo::RGB  },
+};
+
+static const Info* gGetPixelFormatTable(size_t* numEntries) {
+    if (numEntries) {
+        *numEntries = sizeof(sPixelFormatInfos)/sizeof(Info);
+    }
+    return sPixelFormatInfos;
+}
+
+// ----------------------------------------------------------------------------
+
+size_t PixelFormatInfo::getScanlineSize(unsigned int width) const
+{
+    size_t size;
+    if (components == COMPONENT_YUV) {
+        // YCbCr formats are different.
+        size = (width * bitsPerPixel)>>3;
+    } else {
+        size = width * bytesPerPixel;
+    }
+    return size;
+}
+
+status_t getPixelFormatInfo(PixelFormat format, PixelFormatInfo* info)
+{
+    if (format <= 0)
+        return BAD_VALUE;
+
+    if (info->version != sizeof(PixelFormatInfo))
+        return INVALID_OPERATION;
+
+    // YUV format from the HAL are handled here
+    switch (format) {
+    case HAL_PIXEL_FORMAT_YCbCr_422_SP:
+    case HAL_PIXEL_FORMAT_YCbCr_422_I:
+#ifdef STE_HARDWARE
+    case HAL_PIXEL_FORMAT_YCrCb_422_SP:
+    case HAL_PIXEL_FORMAT_YCbCr_422_P:
+    case HAL_PIXEL_FORMAT_YCrCb_422_P:
+    case HAL_PIXEL_FORMAT_CbYCrY_422_I:
+#endif
+        info->bitsPerPixel = 16;
+        goto done;
+    case HAL_PIXEL_FORMAT_YCrCb_420_SP:
+    case HAL_PIXEL_FORMAT_YV12:
+#ifdef STE_HARDWARE
+    case HAL_PIXEL_FORMAT_YCbCr_420_SP:
+    case HAL_PIXEL_FORMAT_YCbCr_420_SP_TILED:
+    case HAL_PIXEL_FORMAT_YCrCb_420_SP_TILED:
+    case HAL_PIXEL_FORMAT_YCbCr_420_P:
+    case HAL_PIXEL_FORMAT_YCrCb_420_P:
+    case HAL_PIXEL_FORMAT_YCbCr_420_I:
+    case HAL_PIXEL_FORMAT_CbYCrY_420_I:
+    case HAL_PIXEL_FORMAT_YCBCR42XMBN:
+#endif
+        info->bitsPerPixel = 12;
+     done:
+        info->format = format;
+        info->components = COMPONENT_YUV;
+        info->bytesPerPixel = 1;
+        info->h_alpha = 0;
+        info->l_alpha = 0;
+        info->h_red = info->h_green = info->h_blue = 8;
+        info->l_red = info->l_green = info->l_blue = 0;
+        return NO_ERROR;
+    }
+
+    size_t numEntries;
+    const Info *i = gGetPixelFormatTable(&numEntries) + format;
+    bool valid = uint32_t(format) < numEntries;
+    if (!valid) {
+        return BAD_INDEX;
+    }
+
+    info->format = format;
+    info->bytesPerPixel = i->size;
+    info->bitsPerPixel  = i->bitsPerPixel;
+    info->h_alpha       = i->ah;
+    info->l_alpha       = i->al;
+    info->h_red         = i->rh;
+    info->l_red         = i->rl;
+    info->h_green       = i->gh;
+    info->l_green       = i->gl;
+    info->h_blue        = i->bh;
+    info->l_blue        = i->bl;
+    info->components    = i->components;
+
+    return NO_ERROR;
+}
+#endif
+
 ssize_t bytesPerPixel(PixelFormat format) {
     switch (format) {
         case PIXEL_FORMAT_RGBA_8888:
@@ -32,21 +155,7 @@ ssize_t bytesPerPixel(PixelFormat format) {
         case PIXEL_FORMAT_RGB_565:
         case PIXEL_FORMAT_RGBA_5551:
         case PIXEL_FORMAT_RGBA_4444:
-#ifdef STE_HARDWARE
-        case HAL_PIXEL_FORMAT_YCrCb_422_SP:
-        case HAL_PIXEL_FORMAT_YCbCr_422_P:
-        case HAL_PIXEL_FORMAT_YCrCb_422_P:
-        case HAL_PIXEL_FORMAT_CbYCrY_422_I:
-        case HAL_PIXEL_FORMAT_YCbCr_420_SP:
-        case HAL_PIXEL_FORMAT_YCbCr_420_SP_TILED:
-        case HAL_PIXEL_FORMAT_YCrCb_420_SP_TILED:
-        case HAL_PIXEL_FORMAT_YCbCr_420_P:
-        case HAL_PIXEL_FORMAT_YCrCb_420_P:
-        case HAL_PIXEL_FORMAT_YCbCr_420_I:
-        case HAL_PIXEL_FORMAT_CbYCrY_420_I:
-        case HAL_PIXEL_FORMAT_YCBCR42XMBN:
-#endif
-	    return 1;
+            return 2;
     }
     return BAD_VALUE;
 }
@@ -62,24 +171,23 @@ ssize_t bitsPerPixel(PixelFormat format) {
         case PIXEL_FORMAT_RGB_565:
         case PIXEL_FORMAT_RGBA_5551:
         case PIXEL_FORMAT_RGBA_4444:
-#ifdef STE_HARDWARE
-	case HAL_PIXEL_FORMAT_YCrCb_422_SP:
-	case HAL_PIXEL_FORMAT_YCbCr_422_P:
-	case HAL_PIXEL_FORMAT_YCrCb_422_P:
-	case HAL_PIXEL_FORMAT_CbYCrY_422_I:
-#endif
             return 16;
-#ifdef STE_HARDWARE
-	case HAL_PIXEL_FORMAT_YCbCr_420_SP:
-	case HAL_PIXEL_FORMAT_YCbCr_420_SP_TILED:
-	case HAL_PIXEL_FORMAT_YCrCb_420_SP_TILED:
-	case HAL_PIXEL_FORMAT_YCbCr_420_P:
-	case HAL_PIXEL_FORMAT_YCrCb_420_P:
-	case HAL_PIXEL_FORMAT_YCbCr_420_I:
-	case HAL_PIXEL_FORMAT_CbYCrY_420_I:
-	case HAL_PIXEL_FORMAT_YCBCR42XMBN:
-#endif
-	    return 12;
+    }
+    return BAD_VALUE;
+}
+
+unsigned int minColorDepth(PixelFormat format) {
+    switch (format) {
+        case PIXEL_FORMAT_RGBA_8888:
+        case PIXEL_FORMAT_RGBX_8888:
+        case PIXEL_FORMAT_BGRA_8888:
+        case PIXEL_FORMAT_RGB_888:
+            return 8;
+        case PIXEL_FORMAT_RGB_565:
+        case PIXEL_FORMAT_RGBA_5551:
+            return 5;
+        case PIXEL_FORMAT_RGBA_4444:
+            return 4;
     }
     return BAD_VALUE;
 }
diff --git a/frameworks/native/opengl/libs/Android.mk b/frameworks/native/opengl/libs/Android.mk
index 528b983..016a9ae 100644
--- a/frameworks/native/opengl/libs/Android.mk
+++ b/frameworks/native/opengl/libs/Android.mk
@@ -51,6 +51,9 @@ endif
 ifeq ($(TARGET_BOARD_PLATFORM), omap4)
   LOCAL_CFLAGS += -DWORKAROUND_BUG_10194508=1
 endif
+ifeq ($(BOARD_EGL_WORKAROUND_BUG_10194508),true)
+  LOCAL_CFLAGS += -DWORKAROUND_BUG_10194508=1
+endif
 ifneq ($(MAX_EGL_CACHE_ENTRY_SIZE),)
   LOCAL_CFLAGS += -DMAX_EGL_CACHE_ENTRY_SIZE=$(MAX_EGL_CACHE_ENTRY_SIZE)
 endif
diff --git a/frameworks/native/opengl/libs/GLES2/gl2.cpp b/frameworks/native/opengl/libs/GLES2/gl2.cpp
index 3134e56..0e929e8 100644
--- a/frameworks/native/opengl/libs/GLES2/gl2.cpp
+++ b/frameworks/native/opengl/libs/GLES2/gl2.cpp
@@ -127,7 +127,7 @@ const GLubyte * glGetString(GLenum name)
     const GLubyte * ret = egl_get_string_for_current_context(name);
     if (ret == NULL) {
         gl_hooks_t::gl_t const * const _c = &getGlThreadSpecific()->gl;
-        ret = _c->glGetString(name);
+        if(_c) ret = _c->glGetString(name);
     }
     return ret;
 }
diff --git a/frameworks/native/services/batteryservice/BatteryProperties.cpp b/frameworks/native/services/batteryservice/BatteryProperties.cpp
index e4a42ed..8c7d287 100644
--- a/frameworks/native/services/batteryservice/BatteryProperties.cpp
+++ b/frameworks/native/services/batteryservice/BatteryProperties.cpp
@@ -33,6 +33,7 @@ status_t BatteryProperties::readFromParcel(Parcel* p) {
     chargerAcOnline = p->readInt32() == 1 ? true : false;
     chargerUsbOnline = p->readInt32() == 1 ? true : false;
     chargerWirelessOnline = p->readInt32() == 1 ? true : false;
+
     batteryStatus = p->readInt32();
     batteryHealth = p->readInt32();
     batteryPresent = p->readInt32() == 1 ? true : false;
@@ -42,6 +43,19 @@ status_t BatteryProperties::readFromParcel(Parcel* p) {
     batteryChargeCounter = p->readInt32();
     batteryTemperature = p->readInt32();
     batteryTechnology = String8((p->readString16()).string());
+
+    chargerDockAcOnline = p->readInt32() == 1 ? true : false;
+    dockBatterySupported = p->readInt32() == 1 ? true : false;
+    dockBatteryStatus = p->readInt32();
+    dockBatteryHealth = p->readInt32();
+    dockBatteryPresent = p->readInt32() == 1 ? true : false;
+    dockBatteryLevel = p->readInt32();
+    dockBatteryVoltage = p->readInt32();
+    dockBatteryCurrentNow = p->readInt32();
+    dockBatteryChargeCounter = p->readInt32();
+    dockBatteryTemperature = p->readInt32();
+    dockBatteryTechnology = String8((p->readString16()).string());
+
     return OK;
 }
 
@@ -49,6 +63,7 @@ status_t BatteryProperties::writeToParcel(Parcel* p) const {
     p->writeInt32(chargerAcOnline ? 1 : 0);
     p->writeInt32(chargerUsbOnline ? 1 : 0);
     p->writeInt32(chargerWirelessOnline ? 1 : 0);
+
     p->writeInt32(batteryStatus);
     p->writeInt32(batteryHealth);
     p->writeInt32(batteryPresent ? 1 : 0);
@@ -58,6 +73,19 @@ status_t BatteryProperties::writeToParcel(Parcel* p) const {
     p->writeInt32(batteryChargeCounter);
     p->writeInt32(batteryTemperature);
     p->writeString16(String16(batteryTechnology));
+
+    p->writeInt32(chargerDockAcOnline ? 1 : 0);
+    p->writeInt32(dockBatterySupported ? 1 : 0);
+    p->writeInt32(dockBatteryStatus);
+    p->writeInt32(dockBatteryHealth);
+    p->writeInt32(dockBatteryPresent ? 1 : 0);
+    p->writeInt32(dockBatteryLevel);
+    p->writeInt32(dockBatteryVoltage);
+    p->writeInt32(dockBatteryCurrentNow);
+    p->writeInt32(dockBatteryChargeCounter);
+    p->writeInt32(dockBatteryTemperature);
+    p->writeString16(String16(dockBatteryTechnology));
+
     return OK;
 }
 
diff --git a/frameworks/native/services/sensorservice/Android.mk b/frameworks/native/services/sensorservice/Android.mk
index 4f24ddc..683af00 100644
--- a/frameworks/native/services/sensorservice/Android.mk
+++ b/frameworks/native/services/sensorservice/Android.mk
@@ -28,6 +28,10 @@ LOCAL_SHARED_LIBRARIES := \
 	libui \
 	libgui
 
+ifneq ($(BOARD_SYSFS_LIGHT_SENSOR),)
+    LOCAL_CFLAGS += -DSYSFS_LIGHT_SENSOR=\"$(BOARD_SYSFS_LIGHT_SENSOR)\"
+endif
+
 LOCAL_MODULE:= libsensorservice
 
 include $(BUILD_SHARED_LIBRARY)
diff --git a/frameworks/native/services/sensorservice/SensorDevice.cpp b/frameworks/native/services/sensorservice/SensorDevice.cpp
index 19caa5c..faaf11b 100644
--- a/frameworks/native/services/sensorservice/SensorDevice.cpp
+++ b/frameworks/native/services/sensorservice/SensorDevice.cpp
@@ -31,11 +31,37 @@
 #include "SensorDevice.h"
 #include "SensorService.h"
 
+#ifdef SYSFS_LIGHT_SENSOR
+#include <fcntl.h>
+#endif
+
 namespace android {
 // ---------------------------------------------------------------------------
 
 ANDROID_SINGLETON_STATIC_INSTANCE(SensorDevice)
 
+#ifdef SYSFS_LIGHT_SENSOR
+#define DUMMY_ALS_HANDLE 0xdeadbeef
+static ssize_t addDummyLightSensor(sensor_t const **list, ssize_t count) {
+    struct sensor_t dummy_light =     {
+                  name            : "CyanogenMod dummy light sensor",
+                  vendor          : "CyanogenMod",
+                  version         : 1,
+                  handle          : DUMMY_ALS_HANDLE,
+                  type            : SENSOR_TYPE_LIGHT,
+                  maxRange        : 20,
+                  resolution      : 0.1,
+                  power           : 20,
+    };
+    void * new_list = malloc((count+1)*sizeof(sensor_t));
+    new_list = memcpy(new_list, *list, count*sizeof(sensor_t));
+    ((sensor_t *)new_list)[count] = dummy_light;
+    *list = (sensor_t const *)new_list;
+    count++;
+    return count;
+}
+#endif
+
 SensorDevice::SensorDevice()
     :  mSensorDevice(0),
        mSensorModule(0)
@@ -55,6 +81,9 @@ SensorDevice::SensorDevice()
         if (mSensorDevice) {
             sensor_t const* list;
             ssize_t count = mSensorModule->get_sensors_list(mSensorModule, &list);
+#ifdef SYSFS_LIGHT_SENSOR
+            count = addDummyLightSensor(&list, count);
+#endif
             mActivationCount.setCapacity(count);
             Info model;
             for (size_t i=0 ; i<size_t(count) ; i++) {
@@ -101,7 +130,11 @@ void SensorDevice::dump(String8& result)
 ssize_t SensorDevice::getSensorList(sensor_t const** list) {
     if (!mSensorModule) return NO_INIT;
     ssize_t count = mSensorModule->get_sensors_list(mSensorModule, list);
+#ifdef SYSFS_LIGHT_SENSOR
+    return addDummyLightSensor(list, count);
+#else
     return count;
+#endif
 }
 
 status_t SensorDevice::initCheck() const {
@@ -129,6 +162,21 @@ status_t SensorDevice::activate(void* ident, int handle, int enabled)
     if (!mSensorDevice) return NO_INIT;
     status_t err(NO_ERROR);
     bool actuateHardware = false;
+#ifdef SYSFS_LIGHT_SENSOR
+    if (handle == DUMMY_ALS_HANDLE) {
+        int nwr, ret, fd;
+        char value[2];
+
+        fd = open(SYSFS_LIGHT_SENSOR, O_RDWR);
+        if(fd < 0)
+            return -ENODEV;
+
+        nwr = snprintf(value, 2, "%d\n", enabled ? 1 : 0);
+        write(fd, value, nwr);
+        close(fd);
+        return 0;
+    }
+#endif
 
     Mutex::Autolock _l(mLock);
     Info& info( mActivationCount.editValueFor(handle) );
diff --git a/frameworks/native/services/sensorservice/SensorService.cpp b/frameworks/native/services/sensorservice/SensorService.cpp
index a2f4332..323c0aa 100644
--- a/frameworks/native/services/sensorservice/SensorService.cpp
+++ b/frameworks/native/services/sensorservice/SensorService.cpp
@@ -594,13 +594,18 @@ status_t SensorService::enable(const sp<SensorEventConnection>& connection,
 
     status_t err = sensor->batch(connection.get(), handle, reservedFlags, samplingPeriodNs,
                                  maxBatchReportLatencyNs);
+
+    const SensorDevice& device(SensorDevice::getInstance());
+
     if (err == NO_ERROR) {
-        connection->setFirstFlushPending(handle, true);
-        status_t err_flush = sensor->flush(connection.get(), handle);
-        // Flush may return error if the sensor is not activated or the underlying h/w sensor does
-        // not support flush.
-        if (err_flush != NO_ERROR) {
-            connection->setFirstFlushPending(handle, false);
+        if (device.getHalDeviceVersion() >= SENSORS_DEVICE_API_VERSION_1_1) {
+            connection->setFirstFlushPending(handle, true);
+            status_t err_flush = sensor->flush(connection.get(), handle);
+            // Flush may return error if the sensor is not activated or the underlying h/w sensor does
+            // not support flush.
+            if (err_flush != NO_ERROR) {
+                connection->setFirstFlushPending(handle, false);
+            }
         }
     }
 
@@ -609,6 +614,11 @@ status_t SensorService::enable(const sp<SensorEventConnection>& connection,
         err = sensor->activate(connection.get(), true);
     }
 
+    if (device.getHalDeviceVersion() < SENSORS_DEVICE_API_VERSION_1_1) {
+        // Pre-1.1 sensor HALs had no flush method, and relied on setDelay at init
+        sensor->setDelay(connection.get(), handle, samplingPeriodNs);
+    }
+
     if (err != NO_ERROR) {
         // batch/activate has failed, reset our state.
         cleanupWithoutDisableLocked(connection, handle);
diff --git a/frameworks/native/services/surfaceflinger/Android.mk b/frameworks/native/services/surfaceflinger/Android.mk
index d25fb2b..4535718 100644
--- a/frameworks/native/services/surfaceflinger/Android.mk
+++ b/frameworks/native/services/surfaceflinger/Android.mk
@@ -37,9 +37,6 @@ LOCAL_SRC_FILES:= \
 LOCAL_CFLAGS:= -DLOG_TAG=\"SurfaceFlinger\"
 LOCAL_CFLAGS += -DGL_GLEXT_PROTOTYPES -DEGL_EGLEXT_PROTOTYPES
 
-ifeq ($(TARGET_BOARD_PLATFORM),omap3)
-	LOCAL_CFLAGS += -DNO_RGBX_8888
-endif
 ifeq ($(TARGET_BOARD_PLATFORM),omap4)
 	LOCAL_CFLAGS += -DHAS_CONTEXT_PRIORITY
 endif
@@ -67,6 +64,10 @@ ifeq ($(TARGET_RUNNING_WITHOUT_SYNC_FRAMEWORK),true)
     LOCAL_CFLAGS += -DRUNNING_WITHOUT_SYNC_FRAMEWORK
 endif
 
+ifeq ($(BOARD_USE_MHEAP_SCREENSHOT),true)
+    LOCAL_CFLAGS += -DUSE_MHEAP_SCREENSHOT
+endif
+
 # See build/target/board/generic/BoardConfig.mk for a description of this setting.
 ifneq ($(VSYNC_EVENT_PHASE_OFFSET_NS),)
     LOCAL_CFLAGS += -DVSYNC_EVENT_PHASE_OFFSET_NS=$(VSYNC_EVENT_PHASE_OFFSET_NS)
@@ -102,6 +103,22 @@ LOCAL_SHARED_LIBRARIES := \
 	libui \
 	libgui
 
+ifeq ($(BOARD_USES_SAMSUNG_HDMI),true)
+        LOCAL_CFLAGS += -DSAMSUNG_HDMI_SUPPORT
+        LOCAL_SHARED_LIBRARIES += libTVOut libhdmiclient
+        LOCAL_C_INCLUDES += hardware/samsung/$(TARGET_BOARD_PLATFORM)/libhdmi/libhdmiservice
+        LOCAL_C_INCLUDES += hardware/samsung/$(TARGET_BOARD_PLATFORM)/include
+endif
+
+ifeq ($(TARGET_USES_QCOM_BSP), true)
+ifneq ($(TARGET_QCOM_DISPLAY_VARIANT),)
+    LOCAL_C_INCLUDES += hardware/qcom/display-$(TARGET_QCOM_DISPLAY_VARIANT)/libgralloc
+else
+    LOCAL_C_INCLUDES += hardware/qcom/display/$(TARGET_BOARD_PLATFORM)/libgralloc
+endif
+    LOCAL_CFLAGS += -DQCOM_BSP
+endif
+
 LOCAL_MODULE:= libsurfaceflinger
 
 include $(BUILD_SHARED_LIBRARY)
diff --git a/frameworks/native/services/surfaceflinger/DisplayDevice.cpp b/frameworks/native/services/surfaceflinger/DisplayDevice.cpp
old mode 100644
new mode 100755
index 55937b4..3e1e161
--- a/frameworks/native/services/surfaceflinger/DisplayDevice.cpp
+++ b/frameworks/native/services/surfaceflinger/DisplayDevice.cpp
@@ -75,6 +75,7 @@ DisplayDevice::DisplayDevice(
       mSecureLayerVisible(false),
       mScreenAcquired(false),
       mLayerStack(NO_LAYER_STACK),
+      mHardwareOrientation(0),
       mOrientation()
 {
 #ifdef STE_HARDWARE
@@ -122,7 +123,12 @@ DisplayDevice::DisplayDevice(
     // was created with createDisplay().
     switch (mType) {
         case DISPLAY_PRIMARY:
+            char value[PROPERTY_VALUE_MAX];
             mDisplayName = "Built-in Screen";
+
+            /* hwrotation applies only to the primary display */
+            property_get("ro.sf.hwrotation", value, "0");
+            mHardwareOrientation = atoi(value);
             break;
         case DISPLAY_EXTERNAL:
             mDisplayName = "HDMI Screen";
@@ -375,6 +381,18 @@ status_t DisplayDevice::orientationToTransfrom(
         int orientation, int w, int h, Transform* tr)
 {
     uint32_t flags = 0;
+    int additionalRot = this->getHardwareOrientation();
+
+    if (additionalRot) {
+        additionalRot /= 90;
+        if (orientation == DisplayState::eOrientationUnchanged) {
+            orientation = additionalRot;
+        } else {
+            orientation += additionalRot;
+            orientation %= 4;
+        }
+    }
+
     switch (orientation) {
     case DisplayState::eOrientationDefault:
         flags = Transform::ROT_0;
@@ -391,6 +409,7 @@ status_t DisplayDevice::orientationToTransfrom(
     default:
         return BAD_VALUE;
     }
+
     tr->set(flags, w, h);
     return NO_ERROR;
 }
@@ -409,7 +428,11 @@ void DisplayDevice::setProjection(int orientation,
     if (!frame.isValid()) {
         // the destination frame can be invalid if it has never been set,
         // in that case we assume the whole display frame.
-        frame = Rect(w, h);
+        if ((mHardwareOrientation/90) & DisplayState::eOrientationSwapMask) {
+            frame = Rect(h, w);
+        } else {
+            frame = Rect(w, h);
+        }
     }
 
     if (viewport.isEmpty()) {
@@ -464,6 +487,10 @@ void DisplayDevice::setProjection(int orientation,
     mFrame = frame;
 }
 
+int DisplayDevice::getHardwareOrientation() {
+    return mHardwareOrientation;
+}
+
 void DisplayDevice::dump(String8& result) const {
     const Transform& tr(mGlobalTransform);
     result.appendFormat(
diff --git a/frameworks/native/services/surfaceflinger/DisplayDevice.cpp.orig b/frameworks/native/services/surfaceflinger/DisplayDevice.cpp.orig
old mode 100644
new mode 100755
index 800137b..f56a1c5
--- a/frameworks/native/services/surfaceflinger/DisplayDevice.cpp.orig
+++ b/frameworks/native/services/surfaceflinger/DisplayDevice.cpp.orig
@@ -71,6 +71,7 @@ DisplayDevice::DisplayDevice(
       mSecureLayerVisible(false),
       mScreenAcquired(false),
       mLayerStack(NO_LAYER_STACK),
+      mHardwareOrientation(0),
       mOrientation()
 {
     mNativeWindow = new Surface(producer, false);
@@ -114,7 +115,12 @@ DisplayDevice::DisplayDevice(
     // was created with createDisplay().
     switch (mType) {
         case DISPLAY_PRIMARY:
+            char value[PROPERTY_VALUE_MAX];
             mDisplayName = "Built-in Screen";
+
+            /* hwrotation applies only to the primary display */
+            property_get("ro.sf.hwrotation", value, "0");
+            mHardwareOrientation = atoi(value);
             break;
         case DISPLAY_EXTERNAL:
             mDisplayName = "HDMI Screen";
@@ -367,6 +373,18 @@ status_t DisplayDevice::orientationToTransfrom(
         int orientation, int w, int h, Transform* tr)
 {
     uint32_t flags = 0;
+    int additionalRot = this->getHardwareOrientation();
+
+    if (additionalRot) {
+        additionalRot /= 90;
+        if (orientation == DisplayState::eOrientationUnchanged) {
+            orientation = additionalRot;
+        } else {
+            orientation += additionalRot;
+            orientation %= 4;
+        }
+    }
+
     switch (orientation) {
     case DisplayState::eOrientationDefault:
         flags = Transform::ROT_0;
@@ -383,6 +401,7 @@ status_t DisplayDevice::orientationToTransfrom(
     default:
         return BAD_VALUE;
     }
+
     tr->set(flags, w, h);
     return NO_ERROR;
 }
@@ -401,7 +420,11 @@ void DisplayDevice::setProjection(int orientation,
     if (!frame.isValid()) {
         // the destination frame can be invalid if it has never been set,
         // in that case we assume the whole display frame.
-        frame = Rect(w, h);
+        if ((mHardwareOrientation/90) & DisplayState::eOrientationSwapMask) {
+            frame = Rect(h, w);
+        } else {
+            frame = Rect(w, h);
+        }
     }
 
     if (viewport.isEmpty()) {
@@ -456,6 +479,10 @@ void DisplayDevice::setProjection(int orientation,
     mFrame = frame;
 }
 
+int DisplayDevice::getHardwareOrientation() {
+    return mHardwareOrientation;
+}
+
 void DisplayDevice::dump(String8& result) const {
     const Transform& tr(mGlobalTransform);
     result.appendFormat(
diff --git a/frameworks/native/services/surfaceflinger/DisplayDevice.h b/frameworks/native/services/surfaceflinger/DisplayDevice.h
index 860e238..170f392 100644
--- a/frameworks/native/services/surfaceflinger/DisplayDevice.h
+++ b/frameworks/native/services/surfaceflinger/DisplayDevice.h
@@ -159,6 +159,7 @@ public:
      */
     uint32_t getPageFlipCount() const;
     void dump(String8& result) const;
+    int getHardwareOrientation();
 
 private:
     /*
@@ -203,10 +204,11 @@ private:
     /*
      * Transaction state
      */
-    static status_t orientationToTransfrom(int orientation,
+    status_t orientationToTransfrom(int orientation,
             int w, int h, Transform* tr);
 
     uint32_t mLayerStack;
+    int mHardwareOrientation;
     int mOrientation;
     // user-provided visible area of the layer stack
     Rect mViewport;
diff --git a/frameworks/native/services/surfaceflinger/DisplayDevice.h.orig b/frameworks/native/services/surfaceflinger/DisplayDevice.h.orig
deleted file mode 100644
index c3abe89..0000000
--- a/frameworks/native/services/surfaceflinger/DisplayDevice.h.orig
+++ /dev/null
@@ -1,221 +0,0 @@
-/*
- * Copyright (C) 2007 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef ANDROID_DISPLAY_DEVICE_H
-#define ANDROID_DISPLAY_DEVICE_H
-
-#include <stdlib.h>
-
-#include <ui/PixelFormat.h>
-#include <ui/Region.h>
-
-#include <EGL/egl.h>
-#include <EGL/eglext.h>
-
-#include <utils/Mutex.h>
-#include <utils/String8.h>
-#include <utils/Timers.h>
-
-#include <hardware/hwcomposer_defs.h>
-
-#include "Transform.h"
-
-struct ANativeWindow;
-
-namespace android {
-
-class DisplayInfo;
-class DisplaySurface;
-class IGraphicBufferProducer;
-class Layer;
-class SurfaceFlinger;
-class HWComposer;
-
-class DisplayDevice : public LightRefBase<DisplayDevice>
-{
-public:
-    // region in layer-stack space
-    mutable Region dirtyRegion;
-    // region in screen space
-    mutable Region swapRegion;
-    // region in screen space
-    Region undefinedRegion;
-
-    enum DisplayType {
-        DISPLAY_ID_INVALID = -1,
-        DISPLAY_PRIMARY     = HWC_DISPLAY_PRIMARY,
-        DISPLAY_EXTERNAL    = HWC_DISPLAY_EXTERNAL,
-        DISPLAY_VIRTUAL     = HWC_DISPLAY_VIRTUAL,
-        NUM_BUILTIN_DISPLAY_TYPES = HWC_NUM_PHYSICAL_DISPLAY_TYPES,
-    };
-
-    enum {
-        PARTIAL_UPDATES = 0x00020000, // video driver feature
-        SWAP_RECTANGLE  = 0x00080000,
-    };
-
-    enum {
-        NO_LAYER_STACK = 0xFFFFFFFF,
-    };
-
-    DisplayDevice(
-            const sp<SurfaceFlinger>& flinger,
-            DisplayType type,
-            int32_t hwcId,  // negative for non-HWC-composited displays
-            bool isSecure,
-            const wp<IBinder>& displayToken,
-            const sp<DisplaySurface>& displaySurface,
-            const sp<IGraphicBufferProducer>& producer,
-            EGLConfig config);
-
-    ~DisplayDevice();
-
-    // whether this is a valid object. An invalid DisplayDevice is returned
-    // when an non existing id is requested
-    bool isValid() const;
-
-    // isSecure indicates whether this display can be trusted to display
-    // secure surfaces.
-    bool isSecure() const { return mIsSecure; }
-
-    // Flip the front and back buffers if the back buffer is "dirty".  Might
-    // be instantaneous, might involve copying the frame buffer around.
-    void flip(const Region& dirty) const;
-
-    int         getWidth() const;
-    int         getHeight() const;
-    PixelFormat getFormat() const;
-    uint32_t    getFlags() const;
-
-    EGLSurface  getEGLSurface() const;
-
-    void                    setVisibleLayersSortedByZ(const Vector< sp<Layer> >& layers);
-    const Vector< sp<Layer> >& getVisibleLayersSortedByZ() const;
-    bool                    getSecureLayerVisible() const;
-    Region                  getDirtyRegion(bool repaintEverything) const;
-
-    void                    setLayerStack(uint32_t stack);
-    void                    setProjection(int orientation, const Rect& viewport, const Rect& frame);
-
-    int                     getOrientation() const { return mOrientation; }
-    uint32_t                getOrientationTransform() const;
-    const Transform&        getTransform() const { return mGlobalTransform; }
-    const Rect              getViewport() const { return mViewport; }
-    const Rect              getFrame() const { return mFrame; }
-    const Rect&             getScissor() const { return mScissor; }
-    bool                    needsFiltering() const { return mNeedsFiltering; }
-
-    uint32_t                getLayerStack() const { return mLayerStack; }
-    int32_t                 getDisplayType() const { return mType; }
-    int32_t                 getHwcDisplayId() const { return mHwcDisplayId; }
-    const wp<IBinder>&      getDisplayToken() const { return mDisplayToken; }
-
-    status_t beginFrame() const;
-    status_t prepareFrame(const HWComposer& hwc) const;
-
-    void swapBuffers(HWComposer& hwc) const;
-    status_t compositionComplete() const;
-
-    // called after h/w composer has completed its set() call
-    void onSwapBuffersCompleted(HWComposer& hwc) const;
-
-    Rect getBounds() const {
-        return Rect(mDisplayWidth, mDisplayHeight);
-    }
-    inline Rect bounds() const { return getBounds(); }
-
-    void setDisplayName(const String8& displayName);
-    const String8& getDisplayName() const { return mDisplayName; }
-
-    EGLBoolean makeCurrent(EGLDisplay dpy, EGLContext ctx) const;
-    void setViewportAndProjection() const;
-
-    /* ------------------------------------------------------------------------
-     * blank / unblank management
-     */
-    void releaseScreen() const;
-    void acquireScreen() const;
-    bool isScreenAcquired() const;
-    bool canDraw() const;
-
-    // release HWC resources (if any) for removable displays
-    void disconnect(HWComposer& hwc);
-
-    /* ------------------------------------------------------------------------
-     * Debugging
-     */
-    uint32_t getPageFlipCount() const;
-    void dump(String8& result) const;
-
-private:
-    /*
-     *  Constants, set during initialization
-     */
-    sp<SurfaceFlinger> mFlinger;
-    DisplayType mType;
-    int32_t mHwcDisplayId;
-    wp<IBinder> mDisplayToken;
-
-    // ANativeWindow this display is rendering into
-    sp<ANativeWindow> mNativeWindow;
-    sp<DisplaySurface> mDisplaySurface;
-
-    EGLDisplay      mDisplay;
-    EGLSurface      mSurface;
-    int             mDisplayWidth;
-    int             mDisplayHeight;
-    PixelFormat     mFormat;
-    uint32_t        mFlags;
-    mutable uint32_t mPageFlipCount;
-    String8         mDisplayName;
-    bool            mIsSecure;
-
-    /*
-     * Can only accessed from the main thread, these members
-     * don't need synchronization.
-     */
-
-    // list of visible layers on that display
-    Vector< sp<Layer> > mVisibleLayersSortedByZ;
-
-    // Whether we have a visible secure layer on this display
-    bool mSecureLayerVisible;
-
-    // Whether the screen is blanked;
-    mutable int mScreenAcquired;
-
-
-    /*
-     * Transaction state
-     */
-    static status_t orientationToTransfrom(int orientation,
-            int w, int h, Transform* tr);
-
-    uint32_t mLayerStack;
-    int mOrientation;
-    // user-provided visible area of the layer stack
-    Rect mViewport;
-    // user-provided rectangle where mViewport gets mapped to
-    Rect mFrame;
-    // pre-computed scissor to apply to the display
-    Rect mScissor;
-    Transform mGlobalTransform;
-    bool mNeedsFiltering;
-};
-
-}; // namespace android
-
-#endif // ANDROID_DISPLAY_DEVICE_H
diff --git a/frameworks/native/services/surfaceflinger/DisplayHardware/FramebufferSurface.cpp b/frameworks/native/services/surfaceflinger/DisplayHardware/FramebufferSurface.cpp
index 8c634ed..4cb0310 100644
--- a/frameworks/native/services/surfaceflinger/DisplayHardware/FramebufferSurface.cpp
+++ b/frameworks/native/services/surfaceflinger/DisplayHardware/FramebufferSurface.cpp
@@ -66,6 +66,7 @@ FramebufferSurface::FramebufferSurface(HWComposer& hwc, int disp,
     mConsumer->setDefaultBufferFormat(mHwc.getFormat(disp));
     mConsumer->setDefaultBufferSize(mHwc.getWidth(disp),  mHwc.getHeight(disp));
     mConsumer->setDefaultMaxBufferCount(NUM_FRAMEBUFFER_SURFACE_BUFFERS);
+    mConsumer->setMaxAcquiredBufferCount(NUM_FRAMEBUFFER_SURFACE_BUFFERS - 1);
 }
 
 status_t FramebufferSurface::beginFrame() {
diff --git a/frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp b/frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp
index c7d1a90..02c8f9b 100644
--- a/frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp
+++ b/frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp
@@ -65,6 +65,107 @@ static bool hwcHasApiVersion(const hwc_composer_device_1_t* hwc,
     return hwcApiVersion(hwc) >= (version & HARDWARE_API_VERSION_2_MAJ_MIN_MASK);
 }
 
+static bool hwcHasVsyncEvent(const hwc_composer_device_1_t* hwc) {
+    return hwcHasApiVersion(hwc, HWC_DEVICE_API_VERSION_0_3) ||
+           hwcHeaderVersion(hwc) >= 3;
+}
+
+static size_t sizeofHwcLayerList(const hwc_composer_device_1_t* hwc,
+        size_t numLayers) {
+    if (hwcHasApiVersion(hwc, HWC_DEVICE_API_VERSION_1_0)) {
+        return sizeof(hwc_display_contents_1_t) + numLayers*sizeof(hwc_layer_1_t);
+    } else {
+        return sizeof(hwc_layer_list_t) + numLayers*sizeof(hwc_layer_t);
+    }
+}
+
+static int hwcEventControl(hwc_composer_device_1_t* hwc, int dpy,
+        int event, int enabled) {
+    if (hwcHasApiVersion(hwc, HWC_DEVICE_API_VERSION_1_0)) {
+        return hwc->eventControl(hwc, dpy, event, enabled);
+    } else {
+        hwc_composer_device_t* hwc0 = reinterpret_cast<hwc_composer_device_t*>(hwc);
+        return hwc0->methods->eventControl(hwc0, event, enabled);
+    }
+}
+
+static int hwcBlank(hwc_composer_device_1_t* hwc, int dpy, int blank) {
+    if (hwcHasApiVersion(hwc, HWC_DEVICE_API_VERSION_1_0)) {
+        return hwc->blank(hwc, dpy, blank);
+    } else {
+        if (blank) {
+            hwc_composer_device_t* hwc0 = reinterpret_cast<hwc_composer_device_t*>(hwc);
+            return hwc0->set(hwc0, NULL, NULL, NULL);
+        } else {
+            // HWC 0.x turns the screen on at the next set()
+            return NO_ERROR;
+        }
+    }
+}
+
+static int hwcPrepare(hwc_composer_device_1_t* hwc,
+        size_t numDisplays, hwc_display_contents_1_t** displays) {
+    if (hwcHasApiVersion(hwc, HWC_DEVICE_API_VERSION_1_0)) {
+        return hwc->prepare(hwc, numDisplays, displays);
+    } else {
+        hwc_composer_device_t* hwc0 = reinterpret_cast<hwc_composer_device_t*>(hwc);
+        hwc_layer_list_t* list0 = reinterpret_cast<hwc_layer_list_t*>(displays[0]);
+        // In the past, SurfaceFlinger would pass a NULL list when doing full
+        // OpenGL ES composition. I don't know what, if any, dependencies there
+        // are on this behavior, so I'm playing it safe and preserving it.
+        // ... and I'm removing it. NULL layers kill the Tegra compositor (RC, Nov 2012)
+        /*if (list0->numHwLayers == 0)
+            return hwc0->prepare(hwc0, NULL);
+        else*/
+            return hwc0->prepare(hwc0, list0);
+    }
+}
+static int hwcSet(hwc_composer_device_1_t* hwc, EGLDisplay dpy, EGLSurface sur,
+        size_t numDisplays, hwc_display_contents_1_t** displays) {
+    int err;
+    if (hwcHasApiVersion(hwc, HWC_DEVICE_API_VERSION_1_0)) {
+        displays[0]->dpy = dpy;
+        displays[0]->sur = sur;
+        err = hwc->set(hwc, numDisplays, displays);
+    } else {
+        hwc_composer_device_t* hwc0 = reinterpret_cast<hwc_composer_device_t*>(hwc);
+        hwc_layer_list_t* list0 = reinterpret_cast<hwc_layer_list_t*>(displays[0]);
+        err = hwc0->set(hwc0, dpy, sur, list0);
+    }
+    return err;
+}
+
+static uint32_t& hwcFlags(hwc_composer_device_1_t* hwc,
+        hwc_display_contents_1_t* display) {
+    if (hwcHasApiVersion(hwc, HWC_DEVICE_API_VERSION_1_0)) {
+        return display->flags;
+    } else {
+        hwc_layer_list_t* list0 = reinterpret_cast<hwc_layer_list_t*>(display);
+        return list0->flags;
+    }
+}
+
+static size_t& hwcNumHwLayers(hwc_composer_device_1_t* hwc,
+        hwc_display_contents_1_t* display) {
+    if (hwcHasApiVersion(hwc, HWC_DEVICE_API_VERSION_1_0)) {
+        return display->numHwLayers;
+    } else {
+        hwc_layer_list_t* list0 = reinterpret_cast<hwc_layer_list_t*>(display);
+        return list0->numHwLayers;
+    }
+}
+
+static void hwcDump(hwc_composer_device_1_t* hwc, char* buff, int buff_len) {
+    if (hwcHasApiVersion(hwc, HWC_DEVICE_API_VERSION_1_0)) {
+        if (hwc->dump)
+            hwc->dump(hwc, buff, buff_len);
+    } else if (hwcHasApiVersion(hwc, HWC_DEVICE_API_VERSION_0_1)) {
+        hwc_composer_device_t* hwc0 = reinterpret_cast<hwc_composer_device_t*>(hwc);
+        if (hwc0->dump)
+            hwc0->dump(hwc0, buff, buff_len);
+    }
+}
+
 // ---------------------------------------------------------------------------
 
 struct HWComposer::cb_context {
@@ -133,32 +234,47 @@ HWComposer::HWComposer(
         ALOGI("Using %s version %u.%u", HWC_HARDWARE_COMPOSER,
               (hwcApiVersion(mHwc) >> 24) & 0xff,
               (hwcApiVersion(mHwc) >> 16) & 0xff);
-        if (mHwc->registerProcs) {
-            mCBContext->hwc = this;
-            mCBContext->procs.invalidate = &hook_invalidate;
-            mCBContext->procs.vsync = &hook_vsync;
-            if (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1))
-                mCBContext->procs.hotplug = &hook_hotplug;
-            else
-                mCBContext->procs.hotplug = NULL;
-            memset(mCBContext->procs.zero, 0, sizeof(mCBContext->procs.zero));
-            mHwc->registerProcs(mHwc, &mCBContext->procs);
+        if (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_0)) {
+            if (mHwc->registerProcs) {
+                mCBContext->hwc = this;
+                mCBContext->procs.invalidate = &hook_invalidate;
+                mCBContext->procs.vsync = &hook_vsync;
+                if (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1))
+                    mCBContext->procs.hotplug = &hook_hotplug;
+                else
+                    mCBContext->procs.hotplug = NULL;
+                memset(mCBContext->procs.zero, 0, sizeof(mCBContext->procs.zero));
+                mHwc->registerProcs(mHwc, &mCBContext->procs);
+            }
+        } else {
+            hwc_composer_device_t* hwc0 = reinterpret_cast<hwc_composer_device_t*>(mHwc);
+            if (hwc0->registerProcs) {
+                mCBContext->hwc = this;
+                mCBContext->procs.invalidate = &hook_invalidate;
+                mCBContext->procs.vsync = &hook_vsync;
+                memset(mCBContext->procs.zero, 0, sizeof(mCBContext->procs.zero));
+                hwc0->registerProcs(hwc0, &mCBContext->procs);
+            }
         }
 
         // don't need a vsync thread if we have a hardware composer
         needVSyncThread = false;
         // always turn vsync off when we start
-        eventControl(HWC_DISPLAY_PRIMARY, HWC_EVENT_VSYNC, 0);
-
-        // the number of displays we actually have depends on the
-        // hw composer version
-        if (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_3)) {
-            // 1.3 adds support for virtual displays
-            mNumDisplays = MAX_HWC_DISPLAYS;
-        } else if (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1)) {
-            // 1.1 adds support for multiple displays
-            mNumDisplays = NUM_BUILTIN_DISPLAYS;
+        if (hwcHasVsyncEvent(mHwc)) {
+            eventControl(HWC_DISPLAY_PRIMARY, HWC_EVENT_VSYNC, 0);
+            // the number of displays we actually have depends on the
+            // hw composer version
+            if (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_3)) {
+                // 1.3 adds support for virtual displays
+                mNumDisplays = MAX_HWC_DISPLAYS;
+            } else if (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1)) {
+                // 1.1 adds support for multiple displays
+                mNumDisplays = NUM_BUILTIN_DISPLAYS;
+            } else {
+                mNumDisplays = 1;
+            }
         } else {
+            needVSyncThread = true;
             mNumDisplays = 1;
         }
     }
@@ -229,9 +345,10 @@ void HWComposer::loadHwcModule()
         return;
     }
 
-    if (!hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_0) ||
+    if (HWC_REMOVE_DEPRECATED_VERSIONS &&
+        (!hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_0) ||
             hwcHeaderVersion(mHwc) < MIN_HWC_HEADER_VERSION ||
-            hwcHeaderVersion(mHwc) > HWC_HEADER_VERSION) {
+            hwcHeaderVersion(mHwc) > HWC_HEADER_VERSION)) {
         ALOGE("%s device version %#x unsupported, will not be used",
               HWC_HARDWARE_COMPOSER, mHwc->common.version);
         hwc_close_1(mHwc);
@@ -476,38 +593,51 @@ void HWComposer::eventControl(int disp, int event, int enabled) {
               event, disp, enabled);
         return;
     }
-    if (event != EVENT_VSYNC) {
-        ALOGW("eventControl got unexpected event %d (disp=%d en=%d)",
-              event, disp, enabled);
-        return;
-    }
     status_t err = NO_ERROR;
-    if (mHwc && !mDebugForceFakeVSync) {
-        // NOTE: we use our own internal lock here because we have to call
-        // into the HWC with the lock held, and we want to make sure
-        // that even if HWC blocks (which it shouldn't), it won't
-        // affect other threads.
-        Mutex::Autolock _l(mEventControlLock);
-        const int32_t eventBit = 1UL << event;
-        const int32_t newValue = enabled ? eventBit : 0;
-        const int32_t oldValue = mDisplayData[disp].events & eventBit;
-        if (newValue != oldValue) {
-            ATRACE_CALL();
-            err = mHwc->eventControl(mHwc, disp, event, enabled);
-            if (!err) {
-                int32_t& events(mDisplayData[disp].events);
-                events = (events & ~eventBit) | newValue;
+    switch(event) {
+        case EVENT_VSYNC:
+            if (mHwc && !mDebugForceFakeVSync && hwcHasVsyncEvent(mHwc)) {
+                if (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_0)) {
+                    // NOTE: we use our own internal lock here because we have to
+                    // call into the HWC with the lock held, and we want to make
+                    // sure that even if HWC blocks (which it shouldn't), it won't
+                    // affect other threads.
+                    Mutex::Autolock _l(mEventControlLock);
+                    const int32_t eventBit = 1UL << event;
+                    const int32_t newValue = enabled ? eventBit : 0;
+                    const int32_t oldValue = mDisplayData[disp].events & eventBit;
+                    if (newValue != oldValue) {
+                        ATRACE_CALL();
+                        err = mHwc->eventControl(mHwc, disp, event, enabled);
+                        if (!err) {
+                            int32_t& events(mDisplayData[disp].events);
+                            events = (events & ~eventBit) | newValue;
+                        }
+                    }
+                } else {
+                    err = hwcEventControl(mHwc, disp, event, enabled);
+                }
+                // error here should not happen -- not sure what we should
+                // do if it does.
+                ALOGE_IF(err, "eventControl(%d, %d) failed %s",
+                         event, enabled, strerror(-err));
             }
-        }
-        // error here should not happen -- not sure what we should
-        // do if it does.
-        ALOGE_IF(err, "eventControl(%d, %d) failed %s",
-                event, enabled, strerror(-err));
-    }
 
-    if (err == NO_ERROR && mVSyncThread != NULL) {
-        mVSyncThread->setEnabled(enabled);
+            if (err == NO_ERROR && mVSyncThread != NULL) {
+                mVSyncThread->setEnabled(enabled);
+            }
+            break;
+        case EVENT_ORIENTATION:
+            // Orientation event
+            if (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_0))
+                err = hwcEventControl(mHwc, disp, event, enabled);
+            break;
+        default:
+            ALOGW("eventControl got unexpected event %d (disp=%d en=%d)",
+                    event, disp, enabled);
+            break;
     }
+    return;
 }
 
 status_t HWComposer::createWorkList(int32_t id, size_t numLayers) {
@@ -522,8 +652,7 @@ status_t HWComposer::createWorkList(int32_t id, size_t numLayers) {
             numLayers++;
         }
         if (disp.capacity < numLayers || disp.list == NULL) {
-            size_t size = sizeof(hwc_display_contents_1_t)
-                    + numLayers * sizeof(hwc_layer_1_t);
+            size_t size = sizeofHwcLayerList(mHwc, numLayers);
             free(disp.list);
             disp.list = (hwc_display_contents_1_t*)malloc(size);
             disp.capacity = numLayers;
@@ -554,9 +683,11 @@ status_t HWComposer::createWorkList(int32_t id, size_t numLayers) {
             disp.framebufferTarget->releaseFenceFd = -1;
             disp.framebufferTarget->planeAlpha = 0xFF;
         }
-        disp.list->retireFenceFd = -1;
-        disp.list->flags = HWC_GEOMETRY_CHANGED;
-        disp.list->numHwLayers = numLayers;
+        if (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_0)) {
+            disp.list->retireFenceFd = -1;
+        }
+        hwcFlags(mHwc, disp.list) = HWC_GEOMETRY_CHANGED;
+        hwcNumHwLayers(mHwc, disp.list) = numLayers;
     }
     return NO_ERROR;
 }
@@ -600,7 +731,7 @@ status_t HWComposer::prepare() {
         }
         if (!disp.connected && disp.list != NULL) {
             ALOGW("WARNING: disp %d: connected, non-null list, layers=%d",
-                  i, disp.list->numHwLayers);
+                    i, hwcNumHwLayers(mHwc, disp.list));
         }
         mLists[i] = disp.list;
         if (mLists[i]) {
@@ -611,34 +742,65 @@ status_t HWComposer::prepare() {
                 // garbage data to catch improper use
                 mLists[i]->dpy = (hwc_display_t)0xDEADBEEF;
                 mLists[i]->sur = (hwc_surface_t)0xDEADBEEF;
-            } else {
+            } else if (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_0)) {
                 mLists[i]->dpy = EGL_NO_DISPLAY;
                 mLists[i]->sur = EGL_NO_SURFACE;
             }
         }
     }
-
-    int err = mHwc->prepare(mHwc, mNumDisplays, mLists);
+    int err = hwcPrepare(mHwc, mNumDisplays, mLists);
     ALOGE_IF(err, "HWComposer: prepare failed (%s)", strerror(-err));
 
     if (err == NO_ERROR) {
-        // here we're just making sure that "skip" layers are set
-        // to HWC_FRAMEBUFFER and we're also counting how many layers
-        // we have of each type.
-        //
-        // If there are no window layers, we treat the display has having FB
-        // composition, because SurfaceFlinger will use GLES to draw the
-        // wormhole region.
-        for (size_t i=0 ; i<mNumDisplays ; i++) {
-            DisplayData& disp(mDisplayData[i]);
+        if (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_0)) {
+            // here we're just making sure that "skip" layers are set
+            // to HWC_FRAMEBUFFER and we're also counting how many layers
+            // we have of each type.
+            for (size_t i=0 ; i<mNumDisplays ; i++) {
+                DisplayData& disp(mDisplayData[i]);
+                disp.hasFbComp = false;
+                disp.hasOvComp = false;
+                if (disp.list) {
+                    for (size_t j=0 ; j<disp.list->numHwLayers ; j++) {
+                        hwc_layer_1_t& l = disp.list->hwLayers[j];
+
+                        //ALOGD("prepare: %d, type=%d, handle=%p",
+                        //        i, l.compositionType, l.handle);
+
+                        if ((i == DisplayDevice::DISPLAY_PRIMARY) &&
+                                    l.flags & HWC_SKIP_LAYER) {
+                            l.compositionType = HWC_FRAMEBUFFER;
+                        }
+                        if (l.compositionType == HWC_FRAMEBUFFER) {
+                            disp.hasFbComp = true;
+                        }
+                        // If the composition type is BLIT, we set this to
+                        // trigger a FLIP
+                        if(l.compositionType == HWC_BLIT) {
+                            disp.hasFbComp = true;
+                        }
+                        if (l.compositionType == HWC_OVERLAY) {
+                            disp.hasOvComp = true;
+                        }
+                    }
+                    if (disp.list->numHwLayers == (disp.framebufferTarget ? 1 : 0)) {
+                        disp.hasFbComp = true;
+                    }
+                } else {
+                    disp.hasFbComp = true;
+                }
+            }
+        } else {
+            DisplayData& disp(mDisplayData[0]);
             disp.hasFbComp = false;
             disp.hasOvComp = false;
             if (disp.list) {
-                for (size_t i=0 ; i<disp.list->numHwLayers ; i++) {
-                    hwc_layer_1_t& l = disp.list->hwLayers[i];
+                hwc_layer_list_t* list0 = reinterpret_cast<hwc_layer_list_t*>(disp.list);
+                for (size_t i=0 ; i<hwcNumHwLayers(mHwc, disp.list) ; i++) {
+                    hwc_layer_t& l = list0->hwLayers[i];
 
                     //ALOGD("prepare: %d, type=%d, handle=%p",
-                    //        i, l.compositionType, l.handle);
+                    //        j, l.compositionType, l.handle);
 
                     if (l.flags & HWC_SKIP_LAYER) {
                         l.compositionType = HWC_FRAMEBUFFER;
@@ -650,11 +812,6 @@ status_t HWComposer::prepare() {
                         disp.hasOvComp = true;
                     }
                 }
-                if (disp.list->numHwLayers == (disp.framebufferTarget ? 1 : 0)) {
-                    disp.hasFbComp = true;
-                }
-            } else {
-                disp.hasFbComp = true;
             }
         }
     }
@@ -692,35 +849,40 @@ sp<Fence> HWComposer::getAndResetReleaseFence(int32_t id) {
 status_t HWComposer::commit() {
     int err = NO_ERROR;
     if (mHwc) {
-        if (!hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1)) {
-            // On version 1.0, the OpenGL ES target surface is communicated
-            // by the (dpy, sur) fields and we are guaranteed to have only
-            // a single display.
-            mLists[0]->dpy = eglGetCurrentDisplay();
-            mLists[0]->sur = eglGetCurrentSurface(EGL_DRAW);
-        }
-
-        for (size_t i=VIRTUAL_DISPLAY_ID_BASE; i<mNumDisplays; i++) {
-            DisplayData& disp(mDisplayData[i]);
-            if (disp.outbufHandle) {
-                mLists[i]->outbuf = disp.outbufHandle;
-                mLists[i]->outbufAcquireFenceFd =
+        if (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_0)) {
+            if (!hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1)) {
+                // On version 1.0, the OpenGL ES target surface is communicated
+                // by the (dpy, sur) fields and we are guaranteed to have only
+                // a single display.
+                mLists[0]->dpy = eglGetCurrentDisplay();
+                mLists[0]->sur = eglGetCurrentSurface(EGL_DRAW);
+            }
+            for (size_t i=VIRTUAL_DISPLAY_ID_BASE; i<mNumDisplays; i++) {
+                DisplayData& disp(mDisplayData[i]);
+                if (disp.outbufHandle) {
+                    mLists[i]->outbuf = disp.outbufHandle;
+                    mLists[i]->outbufAcquireFenceFd =
                         disp.outbufAcquireFence->dup();
+                }
             }
+            err = mHwc->set(mHwc, mNumDisplays, mLists);
+        } else {
+            err = hwcSet(mHwc, eglGetCurrentDisplay(), eglGetCurrentSurface(EGL_DRAW), mNumDisplays,
+                    const_cast<hwc_display_contents_1_t**>(mLists));
         }
 
-        err = mHwc->set(mHwc, mNumDisplays, mLists);
-
         for (size_t i=0 ; i<mNumDisplays ; i++) {
             DisplayData& disp(mDisplayData[i]);
             disp.lastDisplayFence = disp.lastRetireFence;
             disp.lastRetireFence = Fence::NO_FENCE;
             if (disp.list) {
-                if (disp.list->retireFenceFd != -1) {
-                    disp.lastRetireFence = new Fence(disp.list->retireFenceFd);
-                    disp.list->retireFenceFd = -1;
+                if (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_0)) {
+                    if (disp.list->retireFenceFd != -1) {
+                        disp.lastRetireFence = new Fence(disp.list->retireFenceFd);
+                        disp.list->retireFenceFd = -1;
+                    }
                 }
-                disp.list->flags &= ~HWC_GEOMETRY_CHANGED;
+                hwcFlags(mHwc, disp.list) &= ~HWC_GEOMETRY_CHANGED;
             }
         }
     }
@@ -730,8 +892,10 @@ status_t HWComposer::commit() {
 status_t HWComposer::release(int disp) {
     LOG_FATAL_IF(disp >= VIRTUAL_DISPLAY_ID_BASE);
     if (mHwc) {
-        eventControl(disp, HWC_EVENT_VSYNC, 0);
-        return (status_t)mHwc->blank(mHwc, disp, 1);
+        if (hwcHasVsyncEvent(mHwc)) {
+            eventControl(disp, HWC_EVENT_VSYNC, 0);
+        }
+        return (status_t)hwcBlank(mHwc, disp, 1);
     }
     return NO_ERROR;
 }
@@ -739,7 +903,7 @@ status_t HWComposer::release(int disp) {
 status_t HWComposer::acquire(int disp) {
     LOG_FATAL_IF(disp >= VIRTUAL_DISPLAY_ID_BASE);
     if (mHwc) {
-        return (status_t)mHwc->blank(mHwc, disp, 0);
+        return (status_t)hwcBlank(mHwc, disp, 0);
     }
     return NO_ERROR;
 }
@@ -847,6 +1011,145 @@ private:
     }
 };
 
+// #if !HWC_REMOVE_DEPRECATED_VERSIONS
+/*
+ * Concrete implementation of HWCLayer for HWC_DEVICE_API_VERSION_0_3
+ * This implements the HWCLayer side of HWCIterableLayer.
+ */
+class HWCLayerVersion0 : public Iterable<HWCLayerVersion0, hwc_layer_t> {
+public:
+    HWCLayerVersion0(hwc_layer_t* layer)
+        : Iterable<HWCLayerVersion0, hwc_layer_t>(layer) { }
+
+    virtual int32_t getCompositionType() const {
+        return getLayer()->compositionType;
+    }
+    virtual uint32_t getHints() const {
+        return getLayer()->hints;
+    }
+    virtual int getAndResetReleaseFenceFd() {
+        // not supported on VERSION_03
+        return -1;
+    }
+    virtual sp<Fence> getAndResetReleaseFence() {
+        // not supported on VERSION_03
+        return Fence::NO_FENCE;
+    }
+    bool isStatusBar(hwc_layer_t* layer) {
+        /* Getting the display details into the iterator is more trouble than
+         * it's worth, so do a rough approximation */
+
+        // Aligned to the top-left corner and less than 60px tall
+        if (layer->displayFrame.top == 0 &&
+            layer->displayFrame.left == 0 && layer->displayFrame.bottom < 60) {
+            return true;
+        }
+        // Landscape:
+        // Aligned to the top, right-cropped at less than 60px
+        if (layer->displayFrame.top == 0 &&
+            layer->sourceCrop.right < 60) {
+            return true;
+        }
+        // Upside-down:
+        // Left-aligned, bottom-cropped at less than 60, and the projected frame matches the crop height
+        if (layer->displayFrame.left == 0 && layer->sourceCrop.bottom < 60 &&
+            layer->displayFrame.bottom - layer->displayFrame.top == layer->sourceCrop.bottom) {
+            return true;
+        }
+        return false;
+    }
+
+    virtual void setPlaneAlpha(uint8_t alpha) {
+        bool forceSkip = false;
+        // PREMULT on the statusbar layer will artifact miserably on VERSION_03
+        // due to the translucency, so skip compositing
+        if (getLayer()->blending == HWC_BLENDING_PREMULT && isStatusBar(getLayer())) {
+            forceSkip = true;
+        }
+        if (alpha < 0xFF || forceSkip) {
+            getLayer()->flags |= HWC_SKIP_LAYER;
+        }
+    }
+    virtual void setAcquireFenceFd(int fenceFd) {
+        if (fenceFd != -1) {
+            ALOGE("HWC 0.x can't handle acquire fences");
+            close(fenceFd);
+        }
+    }
+    virtual void setDefaultState() {
+        getLayer()->compositionType = HWC_FRAMEBUFFER;
+        getLayer()->hints = 0;
+        getLayer()->flags = HWC_SKIP_LAYER;
+        getLayer()->handle = 0;
+        getLayer()->transform = 0;
+        getLayer()->blending = HWC_BLENDING_NONE;
+        getLayer()->visibleRegionScreen.numRects = 0;
+        getLayer()->visibleRegionScreen.rects = NULL;
+    }
+    virtual void setSkip(bool skip) {
+        if (skip) {
+            getLayer()->flags |= HWC_SKIP_LAYER;
+        } else {
+            getLayer()->flags &= ~HWC_SKIP_LAYER;
+        }
+    }
+    virtual void setAnimating(bool animating) {
+        // Not bothering for legacy path
+    }
+    virtual void setBlending(uint32_t blending) {
+        getLayer()->blending = blending;
+    }
+    virtual void setTransform(uint32_t transform) {
+        getLayer()->transform = transform;
+    }
+    virtual void setFrame(const Rect& frame) {
+        reinterpret_cast<Rect&>(getLayer()->displayFrame) = frame;
+    }
+    virtual void setCrop(const FloatRect& crop) {
+        /*
+         * Since h/w composer didn't support a flot crop rect before version 1.3,
+         * using integer coordinates instead produces a different output from the GL code in
+         * Layer::drawWithOpenGL(). The difference can be large if the buffer crop to
+         * window size ratio is large and a window crop is defined
+         * (i.e.: if we scale the buffer a lot and we also crop it with a window crop).
+         */
+        hwc_rect_t& r = getLayer()->sourceCrop;
+        r.left  = int(ceilf(crop.left));
+        r.top   = int(ceilf(crop.top));
+        r.right = int(floorf(crop.right));
+        r.bottom= int(floorf(crop.bottom));
+    }
+    virtual void setVisibleRegionScreen(const Region& reg) {
+        // Region::getSharedBuffer creates a reference to the underlying
+        // SharedBuffer of this Region, this reference is freed
+        // in onDisplayed()
+        hwc_region_t& visibleRegion = getLayer()->visibleRegionScreen;
+        SharedBuffer const* sb = reg.getSharedBuffer(&visibleRegion.numRects);
+        visibleRegion.rects = reinterpret_cast<hwc_rect_t const *>(sb->data());
+    }
+    virtual void setBuffer(const sp<GraphicBuffer>& buffer) {
+        if (buffer == 0 || buffer->handle == 0) {
+            getLayer()->compositionType = HWC_FRAMEBUFFER;
+            getLayer()->flags |= HWC_SKIP_LAYER;
+            getLayer()->handle = 0;
+        } else {
+            getLayer()->handle = buffer->handle;
+        }
+    }
+    virtual void onDisplayed() {
+        hwc_region_t& visibleRegion = getLayer()->visibleRegionScreen;
+        SharedBuffer const* sb = SharedBuffer::bufferFromData(visibleRegion.rects);
+        if (sb) {
+            sb->release();
+            // not technically needed but safer
+            visibleRegion.numRects = 0;
+            visibleRegion.rects = NULL;
+        }
+
+    }
+};
+// #endif // !HWC_REMOVE_DEPRECATED_VERSIONS
+
 /*
  * Concrete implementation of HWCLayer for HWC_DEVICE_API_VERSION_1_0.
  * This implements the HWCLayer side of HWCIterableLayer.
@@ -904,6 +1207,13 @@ public:
             getLayer()->flags &= ~HWC_SKIP_LAYER;
         }
     }
+    virtual void setAnimating(bool animating) {
+        if (animating) {
+            getLayer()->flags |= HWC_SCREENSHOT_ANIMATOR_LAYER;
+        } else {
+            getLayer()->flags &= ~HWC_SCREENSHOT_ANIMATOR_LAYER;
+        }
+    }
     virtual void setBlending(uint32_t blending) {
         getLayer()->blending = blending;
     }
@@ -970,10 +1280,15 @@ HWComposer::LayerListIterator HWComposer::getLayerIterator(int32_t id, size_t in
         return LayerListIterator();
     }
     const DisplayData& disp(mDisplayData[id]);
-    if (!mHwc || !disp.list || index > disp.list->numHwLayers) {
+    if (!mHwc || !disp.list || index > hwcNumHwLayers(mHwc,disp.list)) {
         return LayerListIterator();
     }
-    return LayerListIterator(new HWCLayerVersion1(mHwc, disp.list->hwLayers), index);
+    if (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_0)) {
+       return LayerListIterator(new HWCLayerVersion1(mHwc, disp.list->hwLayers), index);
+    } else {
+       hwc_layer_list_t* list0 = reinterpret_cast<hwc_layer_list_t*>(disp.list);
+       return LayerListIterator(new HWCLayerVersion0(list0->hwLayers), index);
+    }
 }
 
 /*
@@ -991,7 +1306,7 @@ HWComposer::LayerListIterator HWComposer::end(int32_t id) {
     if (uint32_t(id) <= 31 && mAllocatedDisplayIDs.hasBit(id)) {
         const DisplayData& disp(mDisplayData[id]);
         if (mHwc && disp.list) {
-            numLayers = disp.list->numHwLayers;
+            numLayers = hwcNumHwLayers(mHwc, disp.list);
             if (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_1)) {
                 // with HWC 1.1, the last layer is always the HWC_FRAMEBUFFER_TARGET,
                 // which we ignore when iterating through the layer list.
@@ -1056,6 +1371,7 @@ void HWComposer::dump(String8& result) const {
                             "HWC",
                             "BACKGROUND",
                             "FB TARGET",
+                            "FB_BLIT",
                             "UNKNOWN"};
                     if (type >= NELEM(compositionTypeName))
                         type = NELEM(compositionTypeName) - 1;
@@ -1081,11 +1397,10 @@ void HWComposer::dump(String8& result) const {
             }
         }
     }
-
-    if (mHwc && mHwc->dump) {
+    if (mHwc) {
         const size_t SIZE = 4096;
         char buffer[SIZE];
-        mHwc->dump(mHwc, buffer, SIZE);
+        hwcDump(mHwc, buffer, SIZE);
         result.append(buffer);
     }
 }
@@ -1139,7 +1454,7 @@ bool HWComposer::VSyncThread::threadLoop() {
         err = clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, &spec, NULL);
     } while (err<0 && errno == EINTR);
 
-    if (err == 0) {
+    if (err == 0 && mEnabled) {
         mHwc.mEventHandler.onVSyncReceived(0, next_vsync);
     }
 
diff --git a/frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.h b/frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.h
index 9f96113..8c9e326 100644
--- a/frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.h
+++ b/frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.h
@@ -159,6 +159,7 @@ public:
         virtual sp<Fence> getAndResetReleaseFence() = 0;
         virtual void setDefaultState() = 0;
         virtual void setSkip(bool skip) = 0;
+        virtual void setAnimating(bool animating) = 0;
         virtual void setBlending(uint32_t blending) = 0;
         virtual void setTransform(uint32_t transform) = 0;
         virtual void setFrame(const Rect& frame) = 0;
@@ -240,7 +241,8 @@ public:
     // Events handling ---------------------------------------------------------
 
     enum {
-        EVENT_VSYNC = HWC_EVENT_VSYNC
+        EVENT_VSYNC = HWC_EVENT_VSYNC,
+        EVENT_ORIENTATION = HWC_EVENT_ORIENTATION
     };
 
     void eventControl(int disp, int event, int enabled);
diff --git a/frameworks/native/services/surfaceflinger/DisplayHardware/VirtualDisplaySurface.cpp b/frameworks/native/services/surfaceflinger/DisplayHardware/VirtualDisplaySurface.cpp
index be5cf4a..eb6f229 100644
--- a/frameworks/native/services/surfaceflinger/DisplayHardware/VirtualDisplaySurface.cpp
+++ b/frameworks/native/services/surfaceflinger/DisplayHardware/VirtualDisplaySurface.cpp
@@ -447,6 +447,10 @@ status_t VirtualDisplaySurface::disconnect(int api) {
     return mSource[SOURCE_SINK]->disconnect(api);
 }
 
+status_t VirtualDisplaySurface::setBuffersSize(int size) {
+   return mSource[SOURCE_SINK]->setBuffersSize(size);
+}
+
 void VirtualDisplaySurface::updateQueueBufferOutput(
         const QueueBufferOutput& qbo) {
     uint32_t w, h, transformHint, numPendingBuffers;
diff --git a/frameworks/native/services/surfaceflinger/DisplayHardware/VirtualDisplaySurface.h b/frameworks/native/services/surfaceflinger/DisplayHardware/VirtualDisplaySurface.h
index 1e85ac4..dfd3fd0 100644
--- a/frameworks/native/services/surfaceflinger/DisplayHardware/VirtualDisplaySurface.h
+++ b/frameworks/native/services/surfaceflinger/DisplayHardware/VirtualDisplaySurface.h
@@ -105,6 +105,7 @@ private:
     virtual status_t connect(const sp<IBinder>& token,
             int api, bool producerControlledByApp, QueueBufferOutput* output);
     virtual status_t disconnect(int api);
+    virtual status_t setBuffersSize(int size);
 
     //
     // Utility methods
diff --git a/frameworks/native/services/surfaceflinger/Layer.cpp b/frameworks/native/services/surfaceflinger/Layer.cpp
index 61af51f..fe9fe9a 100644
--- a/frameworks/native/services/surfaceflinger/Layer.cpp
+++ b/frameworks/native/services/surfaceflinger/Layer.cpp
@@ -45,6 +45,9 @@
 #include "DisplayHardware/HWComposer.h"
 
 #include "RenderEngine/RenderEngine.h"
+#ifdef QCOM_BSP
+#include <gralloc_priv.h>
+#endif
 
 #define DEBUG_RESIZE    0
 
@@ -65,6 +68,7 @@ Layer::Layer(SurfaceFlinger* flinger, const sp<Client>& client,
         mDebug(false),
         mFormat(PIXEL_FORMAT_NONE),
         mOpaqueLayer(true),
+        mNeedsDithering(false),
         mTransactionFlags(0),
         mQueuedFrames(0),
         mCurrentTransform(0),
@@ -196,6 +200,12 @@ status_t Layer::setBuffers( uint32_t w, uint32_t h,
     mSurfaceFlingerConsumer->setDefaultBufferFormat(format);
     mSurfaceFlingerConsumer->setConsumerUsageBits(getEffectiveUsage(0));
 
+    if (mFlinger->getUseDithering()) {
+        int displayMinColorDepth = mFlinger->getMinColorDepth();
+        int layerMinColorDepth = minColorDepth(format);
+        mNeedsDithering = (layerMinColorDepth > displayMinColorDepth);
+    }
+
     return NO_ERROR;
 }
 
@@ -364,6 +374,15 @@ void Layer::setGeometry(
     frame.intersect(hw->getViewport(), &frame);
     const Transform& tr(hw->getTransform());
     layer.setFrame(tr.transform(frame));
+#ifdef QCOM_BSP
+    // set dest_rect to frame buffer width and height, if external_only flag
+    // for the layer is enabled.
+    if(isExtOnly()) {
+        uint32_t w = hw->getWidth();
+        uint32_t h = hw->getHeight();
+        layer.setFrame(Rect(w,h));
+    }
+#endif
     layer.setCrop(computeCrop(hw));
     layer.setPlaneAlpha(s.alpha);
 
@@ -425,7 +444,8 @@ void Layer::setAcquireFence(const sp<const DisplayDevice>& hw,
     // TODO: there is a possible optimization here: we only need to set the
     // acquire fence the first time a new buffer is acquired on EACH display.
 
-    if (layer.getCompositionType() == HWC_OVERLAY) {
+    if (layer.getCompositionType() == HWC_OVERLAY ||
+            layer.getCompositionType() == HWC_BLIT) {
         sp<Fence> fence = mSurfaceFlingerConsumer->getCurrentFence();
         if (fence->isValid()) {
             fenceFd = fence->dup();
@@ -490,11 +510,22 @@ void Layer::onDraw(const sp<const DisplayDevice>& hw, const Region& clip) const
         // is probably going to have something visibly wrong.
     }
 
+    bool canAllowGPU = false;
+#ifdef QCOM_BSP
+    if(isProtected()) {
+        char property[PROPERTY_VALUE_MAX];
+        if ((property_get("persist.gralloc.cp.level3", property, NULL) > 0) &&
+                (atoi(property) == 1)) {
+            canAllowGPU = true;
+        }
+    }
+#endif
+
     bool blackOutLayer = isProtected() || (isSecure() && !hw->isSecure());
 
     RenderEngine& engine(mFlinger->getRenderEngine());
 
-    if (!blackOutLayer) {
+    if (!blackOutLayer || (canAllowGPU)) {
         // TODO: we could be more subtle with isFixedSize()
         const bool useFiltering = getFiltering() || needsFiltering(hw) || isFixedSize();
 
@@ -550,6 +581,7 @@ void Layer::clearWithOpenGL(const sp<const DisplayDevice>& hw, const Region& cli
 {
     RenderEngine& engine(mFlinger->getRenderEngine());
     computeGeometry(hw, mMesh);
+    engine.setDither(false);
     engine.setupFillWithColor(red, green, blue, alpha);
     engine.drawMesh(mMesh);
 }
@@ -596,6 +628,7 @@ void Layer::drawWithOpenGL(
     texCoords[3] = vec2(right, 1.0f - top);
 
     RenderEngine& engine(mFlinger->getRenderEngine());
+    engine.setDither(needsDithering());
     engine.setupLayerBlending(mPremultipliedAlpha, isOpaque(), s.alpha);
     engine.drawMesh(mMesh);
     engine.disableBlending();
@@ -1238,6 +1271,41 @@ Layer::LayerCleaner::~LayerCleaner() {
     mFlinger->onLayerDestroyed(mLayer);
 }
 
+#ifdef QCOM_BSP
+bool Layer::isExtOnly() const
+{
+    const sp<GraphicBuffer>& activeBuffer(mActiveBuffer);
+    if (activeBuffer != 0) {
+        uint32_t usage = activeBuffer->getUsage();
+        if(usage & GRALLOC_USAGE_PRIVATE_EXTERNAL_ONLY)
+            return true;
+    }
+    return false;
+}
+
+bool Layer::isIntOnly() const
+{
+    const sp<GraphicBuffer>& activeBuffer(mActiveBuffer);
+    if (activeBuffer != 0) {
+        uint32_t usage = activeBuffer->getUsage();
+        if(usage & GRALLOC_USAGE_PRIVATE_INTERNAL_ONLY)
+            return true;
+    }
+    return false;
+}
+
+bool Layer::isSecureDisplay() const
+{
+    const sp<GraphicBuffer>& activeBuffer(mActiveBuffer);
+    if (activeBuffer != 0) {
+        uint32_t usage = activeBuffer->getUsage();
+        if(usage & GRALLOC_USAGE_PRIVATE_SECURE_DISPLAY)
+            return true;
+    }
+    return false;
+}
+
+#endif
 // ---------------------------------------------------------------------------
 }; // namespace android
 
diff --git a/frameworks/native/services/surfaceflinger/Layer.h b/frameworks/native/services/surfaceflinger/Layer.h
index ef4a7e9..f8387ac 100644
--- a/frameworks/native/services/surfaceflinger/Layer.h
+++ b/frameworks/native/services/surfaceflinger/Layer.h
@@ -153,6 +153,11 @@ public:
     virtual bool isOpaque() const;
 
     /*
+     * needsDithering - true if this surface needs dithering
+     */
+    virtual bool needsDithering() const     { return mNeedsDithering; }
+
+    /*
      * isSecure - true if this surface is secure, that is if it prevents
      * screenshots or VNC servers.
      */
@@ -258,6 +263,11 @@ public:
     // Updates the transform hint in our SurfaceFlingerConsumer to match
     // the current orientation of the display device.
     void updateTransformHint(const sp<const DisplayDevice>& hw) const;
+#ifdef QCOM_BSP
+    virtual bool isExtOnly() const;
+    virtual bool isIntOnly() const;
+    virtual bool isSecureDisplay() const;
+#endif
 
     /*
      * returns the rectangle that crops the content of the layer and scales it
@@ -336,6 +346,7 @@ private:
     mutable bool mDebug;
     PixelFormat mFormat;
     bool mOpaqueLayer;
+    bool mNeedsDithering;
 
     // these are protected by an external lock
     State mCurrentState;
diff --git a/frameworks/native/services/surfaceflinger/RenderEngine/GLES11RenderEngine.cpp b/frameworks/native/services/surfaceflinger/RenderEngine/GLES11RenderEngine.cpp
index 521a5d2..da69965 100644
--- a/frameworks/native/services/surfaceflinger/RenderEngine/GLES11RenderEngine.cpp
+++ b/frameworks/native/services/surfaceflinger/RenderEngine/GLES11RenderEngine.cpp
@@ -185,28 +185,45 @@ void GLES11RenderEngine::disableBlending() {
 }
 
 void GLES11RenderEngine::bindImageAsFramebuffer(EGLImageKHR image,
-        uint32_t* texName, uint32_t* fbName, uint32_t* status) {
+        uint32_t* texName, uint32_t* fbName, uint32_t* status,
+        bool useReadPixels, int reqWidth, int reqHeight) {
     GLuint tname, name;
-    // turn our EGLImage into a texture
-    glGenTextures(1, &tname);
-    glBindTexture(GL_TEXTURE_2D, tname);
-    glEGLImageTargetTexture2DOES(GL_TEXTURE_2D, (GLeglImageOES)image);
-
-    // create a Framebuffer Object to render into
-    glGenFramebuffersOES(1, &name);
-    glBindFramebufferOES(GL_FRAMEBUFFER_OES, name);
-    glFramebufferTexture2DOES(GL_FRAMEBUFFER_OES,
-            GL_COLOR_ATTACHMENT0_OES, GL_TEXTURE_2D, tname, 0);
+    if (!useReadPixels) {
+        // turn our EGLImage into a texture
+        glGenTextures(1, &tname);
+        glBindTexture(GL_TEXTURE_2D, tname);
+        glEGLImageTargetTexture2DOES(GL_TEXTURE_2D, (GLeglImageOES)image);
+
+        // create a Framebuffer Object to render into
+        glGenFramebuffersOES(1, &name);
+        glBindFramebufferOES(GL_FRAMEBUFFER_OES, name);
+        glFramebufferTexture2DOES(GL_FRAMEBUFFER_OES,
+                GL_COLOR_ATTACHMENT0_OES, GL_TEXTURE_2D, tname, 0);
+    } else {
+        // since we're going to use glReadPixels() anyways,
+        // use an intermediate renderbuffer instead
+        glGenRenderbuffersOES(1, &tname);
+        glBindRenderbufferOES(GL_RENDERBUFFER_OES, tname);
+        glRenderbufferStorageOES(GL_RENDERBUFFER_OES, GL_RGBA8_OES, reqWidth, reqHeight);
+        // create a FBO to render into
+        glGenFramebuffersOES(1, &name);
+        glBindFramebufferOES(GL_FRAMEBUFFER_OES, name);
+        glFramebufferRenderbufferOES(GL_FRAMEBUFFER_OES, GL_COLOR_ATTACHMENT0_OES, GL_RENDERBUFFER_OES, tname);
+    }
 
     *status = glCheckFramebufferStatusOES(GL_FRAMEBUFFER_OES);
     *texName = tname;
     *fbName = name;
 }
 
-void GLES11RenderEngine::unbindFramebuffer(uint32_t texName, uint32_t fbName) {
+void GLES11RenderEngine::unbindFramebuffer(uint32_t texName, uint32_t fbName,
+        bool useReadPixels) {
     glBindFramebufferOES(GL_FRAMEBUFFER_OES, 0);
     glDeleteFramebuffersOES(1, &fbName);
-    glDeleteTextures(1, &texName);
+    if (!useReadPixels)
+        glDeleteTextures(1, &texName);
+    else
+        glDeleteRenderbuffersOES(1, &texName);
 }
 
 void GLES11RenderEngine::setupFillWithColor(float r, float g, float b, float a) {
diff --git a/frameworks/native/services/surfaceflinger/RenderEngine/GLES11RenderEngine.h b/frameworks/native/services/surfaceflinger/RenderEngine/GLES11RenderEngine.h
index cd53aab..6e4c46e 100644
--- a/frameworks/native/services/surfaceflinger/RenderEngine/GLES11RenderEngine.h
+++ b/frameworks/native/services/surfaceflinger/RenderEngine/GLES11RenderEngine.h
@@ -39,8 +39,8 @@ class GLES11RenderEngine : public RenderEngine {
     GLint mMaxTextureSize;
 
     virtual void bindImageAsFramebuffer(EGLImageKHR image,
-            uint32_t* texName, uint32_t* fbName, uint32_t* status);
-    virtual void unbindFramebuffer(uint32_t texName, uint32_t fbName);
+            uint32_t* texName, uint32_t* fbName, uint32_t* status, bool useReadPixels, int reqWidth, int reqHeight);
+    virtual void unbindFramebuffer(uint32_t texName, uint32_t fbName, bool useReadPixels);
 
 public:
     GLES11RenderEngine();
diff --git a/frameworks/native/services/surfaceflinger/RenderEngine/GLES20RenderEngine.cpp b/frameworks/native/services/surfaceflinger/RenderEngine/GLES20RenderEngine.cpp
index a2a6270..ada3ab0 100644
--- a/frameworks/native/services/surfaceflinger/RenderEngine/GLES20RenderEngine.cpp
+++ b/frameworks/native/services/surfaceflinger/RenderEngine/GLES20RenderEngine.cpp
@@ -151,27 +151,44 @@ void GLES20RenderEngine::disableBlending() {
 
 
 void GLES20RenderEngine::bindImageAsFramebuffer(EGLImageKHR image,
-        uint32_t* texName, uint32_t* fbName, uint32_t* status) {
+        uint32_t* texName, uint32_t* fbName, uint32_t* status,
+        bool useReadPixels, int reqWidth, int reqHeight) {
     GLuint tname, name;
-    // turn our EGLImage into a texture
-    glGenTextures(1, &tname);
-    glBindTexture(GL_TEXTURE_2D, tname);
-    glEGLImageTargetTexture2DOES(GL_TEXTURE_2D, (GLeglImageOES)image);
-
-    // create a Framebuffer Object to render into
-    glGenFramebuffers(1, &name);
-    glBindFramebuffer(GL_FRAMEBUFFER, name);
-    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, tname, 0);
+    if (!useReadPixels) {
+        // turn our EGLImage into a texture
+        glGenTextures(1, &tname);
+        glBindTexture(GL_TEXTURE_2D, tname);
+        glEGLImageTargetTexture2DOES(GL_TEXTURE_2D, (GLeglImageOES)image);
+
+        // create a Framebuffer Object to render into
+        glGenFramebuffers(1, &name);
+        glBindFramebuffer(GL_FRAMEBUFFER, name);
+        glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, tname, 0);
+    } else {
+        // since we're going to use glReadPixels() anyways,
+        // use an intermediate renderbuffer instead
+        glGenRenderbuffers(1, &tname);
+        glBindRenderbuffer(GL_RENDERBUFFER, tname);
+        glRenderbufferStorage(GL_RENDERBUFFER, GL_RGBA8_OES, reqWidth, reqHeight);
+        // create a FBO to render into
+        glGenFramebuffers(1, &name);
+        glBindFramebuffer(GL_FRAMEBUFFER, name);
+        glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, tname);
+    }
 
     *status = glCheckFramebufferStatus(GL_FRAMEBUFFER);
     *texName = tname;
     *fbName = name;
 }
 
-void GLES20RenderEngine::unbindFramebuffer(uint32_t texName, uint32_t fbName) {
+void GLES20RenderEngine::unbindFramebuffer(uint32_t texName, uint32_t fbName,
+        bool useReadPixels) {
     glBindFramebuffer(GL_FRAMEBUFFER, 0);
     glDeleteFramebuffers(1, &fbName);
-    glDeleteTextures(1, &texName);
+    if (!useReadPixels)
+        glDeleteTextures(1, &texName);
+    else
+        glDeleteRenderbuffers(1, &texName);
 }
 
 void GLES20RenderEngine::setupFillWithColor(float r, float g, float b, float a) {
diff --git a/frameworks/native/services/surfaceflinger/RenderEngine/GLES20RenderEngine.h b/frameworks/native/services/surfaceflinger/RenderEngine/GLES20RenderEngine.h
index 8b67fcc..d5c5b5d 100644
--- a/frameworks/native/services/surfaceflinger/RenderEngine/GLES20RenderEngine.h
+++ b/frameworks/native/services/surfaceflinger/RenderEngine/GLES20RenderEngine.h
@@ -54,8 +54,9 @@ class GLES20RenderEngine : public RenderEngine {
     Vector<Group> mGroupStack;
 
     virtual void bindImageAsFramebuffer(EGLImageKHR image,
-            uint32_t* texName, uint32_t* fbName, uint32_t* status);
-    virtual void unbindFramebuffer(uint32_t texName, uint32_t fbName);
+            uint32_t* texName, uint32_t* fbName, uint32_t* status,
+            bool useReadPixels, int reqWidth, int reqHeight);
+    virtual void unbindFramebuffer(uint32_t texName, uint32_t fbName, bool useReadPixels);
 
 public:
     GLES20RenderEngine();
diff --git a/frameworks/native/services/surfaceflinger/RenderEngine/RenderEngine.cpp b/frameworks/native/services/surfaceflinger/RenderEngine/RenderEngine.cpp
index ba82cad..ab5dfc8 100644
--- a/frameworks/native/services/surfaceflinger/RenderEngine/RenderEngine.cpp
+++ b/frameworks/native/services/surfaceflinger/RenderEngine/RenderEngine.cpp
@@ -205,6 +205,14 @@ void RenderEngine::readPixels(size_t l, size_t b, size_t w, size_t h, uint32_t*
     glReadPixels(l, b, w, h, GL_RGBA, GL_UNSIGNED_BYTE, pixels);
 }
 
+void RenderEngine::setDither(bool dither) {
+    if (dither) {
+        glEnable(GL_DITHER);
+    } else {
+        glDisable(GL_DITHER);
+    }
+}
+
 void RenderEngine::dump(String8& result) {
     const GLExtensions& extensions(GLExtensions::getInstance());
     result.appendFormat("GLES: %s, %s, %s\n",
@@ -217,9 +225,11 @@ void RenderEngine::dump(String8& result) {
 // ---------------------------------------------------------------------------
 
 RenderEngine::BindImageAsFramebuffer::BindImageAsFramebuffer(
-        RenderEngine& engine, EGLImageKHR image) : mEngine(engine)
+        RenderEngine& engine, EGLImageKHR image, bool useReadPixels,
+        int reqWidth, int reqHeight) : mEngine(engine), mUseReadPixels(useReadPixels)
 {
-    mEngine.bindImageAsFramebuffer(image, &mTexName, &mFbName, &mStatus);
+    mEngine.bindImageAsFramebuffer(image, &mTexName, &mFbName, &mStatus,
+            useReadPixels, reqWidth, reqHeight);
 
     ALOGE_IF(mStatus != GL_FRAMEBUFFER_COMPLETE_OES,
             "glCheckFramebufferStatusOES error %d", mStatus);
@@ -227,7 +237,7 @@ RenderEngine::BindImageAsFramebuffer::BindImageAsFramebuffer(
 
 RenderEngine::BindImageAsFramebuffer::~BindImageAsFramebuffer() {
     // back to main framebuffer
-    mEngine.unbindFramebuffer(mTexName, mFbName);
+    mEngine.unbindFramebuffer(mTexName, mFbName, mUseReadPixels);
 }
 
 status_t RenderEngine::BindImageAsFramebuffer::getStatus() const {
diff --git a/frameworks/native/services/surfaceflinger/RenderEngine/RenderEngine.h b/frameworks/native/services/surfaceflinger/RenderEngine/RenderEngine.h
index 3c7f9ab..1ff5e90 100644
--- a/frameworks/native/services/surfaceflinger/RenderEngine/RenderEngine.h
+++ b/frameworks/native/services/surfaceflinger/RenderEngine/RenderEngine.h
@@ -47,8 +47,8 @@ class RenderEngine {
     EGLContext mEGLContext;
     void setEGLContext(EGLContext ctxt);
 
-    virtual void bindImageAsFramebuffer(EGLImageKHR image, uint32_t* texName, uint32_t* fbName, uint32_t* status) = 0;
-    virtual void unbindFramebuffer(uint32_t texName, uint32_t fbName) = 0;
+    virtual void bindImageAsFramebuffer(EGLImageKHR image, uint32_t* texName, uint32_t* fbName, uint32_t* status, bool useReadPixels, int reqWidth, int reqHeight) = 0;
+    virtual void unbindFramebuffer(uint32_t texName, uint32_t fbName, bool useReadPixels) = 0;
 
 protected:
     RenderEngine();
@@ -72,12 +72,15 @@ public:
     void deleteTextures(size_t count, uint32_t const* names);
     void readPixels(size_t l, size_t b, size_t w, size_t h, uint32_t* pixels);
 
+    void setDither(bool dither);
+
     class BindImageAsFramebuffer {
         RenderEngine& mEngine;
         uint32_t mTexName, mFbName;
         uint32_t mStatus;
+        bool mUseReadPixels;
     public:
-        BindImageAsFramebuffer(RenderEngine& engine, EGLImageKHR image);
+        BindImageAsFramebuffer(RenderEngine& engine, EGLImageKHR image, bool useReadPixels, int reqWidth, int reqHeight);
         ~BindImageAsFramebuffer();
         int getStatus() const;
     };
diff --git a/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp b/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp
index 1c62796..a934891 100644
--- a/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp
+++ b/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp
@@ -23,6 +23,9 @@
 #include <dlfcn.h>
 
 #include <EGL/egl.h>
+#ifdef USE_MHEAP_SCREENSHOT
+#include <GLES/gl.h>
+#endif
 
 #include <cutils/log.h>
 #include <cutils/properties.h>
@@ -75,6 +78,10 @@
 #include "RenderEngine/RenderEngine.h"
 #include <cutils/compiler.h>
 
+#ifdef SAMSUNG_HDMI_SUPPORT
+#include "SecTVOutService.h"
+#endif
+
 #define DISPLAY_COUNT       1
 
 /*
@@ -150,6 +157,7 @@ SurfaceFlinger::SurfaceFlinger()
         mDebugInTransaction(0),
         mLastTransactionTime(0),
         mBootFinished(false),
+        mUseDithering(false),
         mPrimaryHWVsyncEnabled(false),
         mHWVsyncAvailable(false),
         mDaltonize(false)
@@ -175,6 +183,16 @@ SurfaceFlinger::SurfaceFlinger()
     }
     ALOGI_IF(mDebugRegion, "showupdates enabled");
     ALOGI_IF(mDebugDDMS, "DDMS debugging enabled");
+
+#ifdef SAMSUNG_HDMI_SUPPORT
+    ALOGD(">>> Run service");
+    android::SecTVOutService::instantiate();
+#if defined(SAMSUNG_EXYNOS5250)
+    mHdmiClient = SecHdmiClient::getInstance();
+    mHdmiClient->setHdmiEnable(1);
+#endif
+#endif
+
 }
 
 void SurfaceFlinger::onFirstRef()
@@ -556,6 +574,9 @@ void SurfaceFlinger::init() {
     ALOGI("Client API: %s", eglQueryString(mEGLDisplay, EGL_CLIENT_APIS)?:"Not Supported");
     ALOGI("EGLSurface: %d-%d-%d-%d, config=%p", r, g, b, a, mEGLConfig);
 
+    // assume red has minimum color depth
+    mMinColorDepth = r;
+
     // get a RenderEngine for the given display / config (can't fail)
     mRenderEngine = RenderEngine::create(mEGLDisplay, mEGLConfig);
 
@@ -593,6 +614,9 @@ void SurfaceFlinger::init() {
                 hw->acquireScreen();
             }
             mDisplays.add(token, hw);
+            if (!mUseDithering && bitsPerPixel(mHwc->getFormat(i)) <= 16) {
+                mUseDithering = true;
+            }
         }
     }
 
@@ -605,7 +629,7 @@ void SurfaceFlinger::init() {
             vsyncPhaseOffsetNs, true);
     mEventThread = new EventThread(vsyncSrc);
     sp<VSyncSource> sfVsyncSrc = new DispSyncSource(&mPrimaryDispSync,
-            sfVsyncPhaseOffsetNs, false);
+            sfVsyncPhaseOffsetNs, true);
     mSFEventThread = new EventThread(sfVsyncSrc);
     mEventQueue.setEventThread(mSFEventThread);
 
@@ -715,10 +739,19 @@ status_t SurfaceFlinger::getDisplayInfo(const sp<IBinder>& display, DisplayInfo*
         info->orientation = 0;
     }
 
-    info->w = hwc.getWidth(type);
-    info->h = hwc.getHeight(type);
-    info->xdpi = xdpi;
-    info->ydpi = ydpi;
+    int additionalRot = mDisplays[0]->getHardwareOrientation() / 90;
+    if ((type == DisplayDevice::DISPLAY_PRIMARY) && (additionalRot & DisplayState::eOrientationSwapMask)) {
+        info->h = hwc.getWidth(type);
+        info->w = hwc.getHeight(type);
+        info->xdpi = ydpi;
+        info->ydpi = xdpi;
+    }
+    else {
+        info->w = hwc.getWidth(type);
+        info->h = hwc.getHeight(type);
+        info->xdpi = xdpi;
+        info->ydpi = ydpi;
+    }
     info->fps = float(1e9 / hwc.getRefreshPeriod(type));
 
     // All non-virtual displays are currently considered secure.
@@ -1013,21 +1046,20 @@ void SurfaceFlinger::rebuildLayerStacks() {
             const sp<DisplayDevice>& hw(mDisplays[dpy]);
             const Transform& tr(hw->getTransform());
             const Rect bounds(hw->getBounds());
+            int dpyId = hw->getHwcDisplayId();
             if (hw->canDraw()) {
-                SurfaceFlinger::computeVisibleRegions(layers,
+                SurfaceFlinger::computeVisibleRegions(dpyId, layers,
                         hw->getLayerStack(), dirtyRegion, opaqueRegion);
 
                 const size_t count = layers.size();
                 for (size_t i=0 ; i<count ; i++) {
                     const sp<Layer>& layer(layers[i]);
                     const Layer::State& s(layer->getDrawingState());
-                    if (s.layerStack == hw->getLayerStack()) {
-                        Region drawRegion(tr.transform(
-                                layer->visibleNonTransparentRegion));
-                        drawRegion.andSelf(bounds);
-                        if (!drawRegion.isEmpty()) {
-                            layersSortedByZ.add(layer);
-                        }
+                    Region drawRegion(tr.transform(
+                            layer->visibleNonTransparentRegion));
+                    drawRegion.andSelf(bounds);
+                    if (!drawRegion.isEmpty()) {
+                        layersSortedByZ.add(layer);
                     }
                 }
             }
@@ -1076,6 +1108,26 @@ void SurfaceFlinger::setUpHWComposer() {
             sp<const DisplayDevice> hw(mDisplays[dpy]);
             const int32_t id = hw->getHwcDisplayId();
             if (id >= 0) {
+                // Get the layers in the current drawying state
+                const LayerVector& layers(mDrawingState.layersSortedByZ);
+                bool freezeSurfacePresent = false;
+                const size_t layerCount = layers.size();
+                char value[PROPERTY_VALUE_MAX];
+                property_get("sys.disable_ext_animation", value, "0");
+                if(atoi(value)) {
+                    for (size_t i = 0 ; i < layerCount ; ++i) {
+                        static int screenShotLen = strlen("ScreenshotSurface");
+                        const sp<Layer>& layer(layers[i]);
+                        if(!strncmp(layer->getName(), "ScreenshotSurface",
+                                    screenShotLen)) {
+                            // Screenshot layer is present, and animation in
+                            // progress
+                            freezeSurfacePresent = true;
+                            break;
+                        }
+                    }
+                }
+
                 const Vector< sp<Layer> >& currentLayers(
                     hw->getVisibleLayersSortedByZ());
                 const size_t count = currentLayers.size();
@@ -1088,6 +1140,26 @@ void SurfaceFlinger::setUpHWComposer() {
                      */
                     const sp<Layer>& layer(currentLayers[i]);
                     layer->setPerFrameData(hw, *cur);
+                    if(freezeSurfacePresent) {
+                        // if freezeSurfacePresent, set ANIMATING flag
+                        cur->setAnimating(true);
+                    } else {
+                        const KeyedVector<wp<IBinder>, DisplayDeviceState>&
+                                                draw(mDrawingState.displays);
+                        size_t dc = draw.size();
+                        for (size_t i=0 ; i<dc ; i++) {
+                            if (draw[i].isMainDisplay()) {
+                                HWComposer& hwc(getHwComposer());
+                                if (hwc.initCheck() == NO_ERROR)
+                                    // Pass the current orientation to HWC
+                                    // which will be used to block animation
+                                    // on external
+                                    hwc.eventControl(HWC_DISPLAY_PRIMARY,
+                                            SurfaceFlinger::EVENT_ORIENTATION,
+                                            uint32_t(draw[i].orientation));
+                            }
+                        }
+                    }
                 }
             }
         }
@@ -1205,6 +1277,26 @@ void SurfaceFlinger::handleTransaction(uint32_t transactionFlags)
     // here the transaction has been committed
 }
 
+void SurfaceFlinger::setVirtualDisplayData(
+    int32_t hwcDisplayId,
+    const sp<IGraphicBufferProducer>& sink)
+{
+    sp<ANativeWindow> mNativeWindow = new Surface(sink);
+    ANativeWindow* const window = mNativeWindow.get();
+
+    int format;
+    window->query(window, NATIVE_WINDOW_FORMAT, &format);
+
+    EGLSurface surface;
+    EGLint w, h;
+    EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
+    surface = eglCreateWindowSurface(display, mEGLConfig, window, NULL);
+    eglQuerySurface(display, surface, EGL_WIDTH,  &w);
+    eglQuerySurface(display, surface, EGL_HEIGHT, &h);
+
+    mHwc->setVirtualDisplayProperties(hwcDisplayId, w, h, format);
+}
+
 void SurfaceFlinger::handleTransactionLocked(uint32_t transactionFlags)
 {
     const LayerVector& currentLayers(mCurrentState.layersSortedByZ);
@@ -1317,18 +1409,32 @@ void SurfaceFlinger::handleTransactionLocked(uint32_t transactionFlags)
                         // etc.) but no internal state (i.e. a DisplayDevice).
                         if (state.surface != NULL) {
 
+                            char value[PROPERTY_VALUE_MAX];
                             hwcDisplayId = allocateHwcDisplayId(state.type);
-                            sp<VirtualDisplaySurface> vds = new VirtualDisplaySurface(
+                            property_get("persist.sys.wfd.virtual", value, "0");
+                            int wfdVirtual = atoi(value);
+                            if(!wfdVirtual) {
+                                sp<VirtualDisplaySurface> vds =
+                                              new VirtualDisplaySurface(
                                     *mHwc, hwcDisplayId, state.surface, bq,
                                     state.displayName);
-
-                            dispSurface = vds;
-                            if (hwcDisplayId >= 0) {
-                                producer = vds;
+                                dispSurface = vds;
+                                if (hwcDisplayId >= 0) {
+                                   producer = vds;
+                                } else {
+                                  // There won't be any interaction with HWC for this virtual display,
+                                  // so the GLES driver can pass buffers directly to the sink.
+                                  producer = state.surface;
+                                }
                             } else {
-                                // There won't be any interaction with HWC for this virtual display,
-                                // so the GLES driver can pass buffers directly to the sink.
-                                producer = state.surface;
+                                //Read virtual display properties and create a
+                                //rendering surface for it inorder to be handled
+                                //by hwc.
+                                setVirtualDisplayData(hwcDisplayId,
+                                                                 state.surface);
+                                dispSurface = new FramebufferSurface(*mHwc,
+                                                                    state.type, bq);
+                                producer = bq;
                             }
                         }
                     } else {
@@ -1344,7 +1450,7 @@ void SurfaceFlinger::handleTransactionLocked(uint32_t transactionFlags)
                     }
 
                     const wp<IBinder>& display(curr.keyAt(i));
-                    if (dispSurface != NULL) {
+                    if (dispSurface != NULL && producer != NULL) {
                         sp<DisplayDevice> hw = new DisplayDevice(this,
                                 state.type, hwcDisplayId, state.isSecure,
                                 display, dispSurface, producer, mEGLConfig);
@@ -1482,7 +1588,7 @@ void SurfaceFlinger::commitTransaction()
     mTransactionCV.broadcast();
 }
 
-void SurfaceFlinger::computeVisibleRegions(
+void SurfaceFlinger::computeVisibleRegions(size_t dpy,
         const LayerVector& currentLayers, uint32_t layerStack,
         Region& outDirtyRegion, Region& outOpaqueRegion)
 {
@@ -1493,18 +1599,63 @@ void SurfaceFlinger::computeVisibleRegions(
     Region dirty;
 
     outDirtyRegion.clear();
-
+    bool bIgnoreLayers = false;
+    int indexLOI = -1;
     size_t i = currentLayers.size();
+#ifdef QCOM_BSP
+    while (i--) {
+        const sp<Layer>& layer = currentLayers[i];
+        // iterate through the layer list to find ext_only layers and store
+        // the index
+        if (layer->isSecureDisplay()) {
+            bIgnoreLayers = true;
+            indexLOI = -1;
+            if(!dpy)
+                indexLOI = i;
+            break;
+        }
+
+        if (dpy && layer->isExtOnly()) {
+            bIgnoreLayers = true;
+            indexLOI = i;
+        }
+    }
+    i = currentLayers.size();
+#endif
     while (i--) {
         const sp<Layer>& layer = currentLayers[i];
 
         // start with the whole surface at its current location
         const Layer::State& s(layer->getDrawingState());
 
-        // only consider the layers on the given layer stack
-        if (s.layerStack != layerStack)
+#ifdef QCOM_BSP
+        // Only add the layer marked as "external_only" to external list and
+        // only remove the layer marked as "external_only" from primary list
+        // and do not add the layer marked as "internal_only" to external list
+        // Add secure UI layers to primary and remove other layers from internal
+        //and external list
+        if((bIgnoreLayers && indexLOI != (int)i) ||
+           (!dpy && layer->isExtOnly()) ||
+           (dpy && layer->isIntOnly())) {
+            // Ignore all other layers except the layers marked as ext_only
+            // by setting visible non transparent region empty.
+            Region visibleNonTransRegion;
+            visibleNonTransRegion.set(Rect(0,0));
+            layer->setVisibleNonTransparentRegion(visibleNonTransRegion);
             continue;
-
+        }
+#endif
+        // only consider the layers on the given later stack
+        // Override layers created using presentation class by the layers having
+        // ext_only flag enabled
+        if(s.layerStack != layerStack && !bIgnoreLayers) {
+            // set the visible region as empty since we have removed the
+            // layerstack check in rebuildLayerStack() function.
+            Region visibleNonTransRegion;
+            visibleNonTransRegion.set(Rect(0,0));
+            layer->setVisibleNonTransparentRegion(visibleNonTransRegion);
+            continue;
+        }
         /*
          * opaqueRegion: area of a surface that is fully opaque.
          */
@@ -1740,8 +1891,12 @@ void SurfaceFlinger::doComposeSurfaces(const sp<const DisplayDevice>& hw, const
 
             // screen is already cleared here
             if (!region.isEmpty()) {
-                // can happen with SurfaceView
-                drawWormhole(hw, region);
+                if (cur != end) {
+                    if (cur->getCompositionType() != HWC_BLIT)
+                        // can happen with SurfaceView
+                        drawWormhole(hw, region);
+                } else
+                    drawWormhole(hw, region);
             }
         }
 
@@ -1794,6 +1949,9 @@ void SurfaceFlinger::doComposeSurfaces(const sp<const DisplayDevice>& hw, const
                         layer->draw(hw, clip);
                         break;
                     }
+                    case HWC_BLIT:
+                        //Do nothing
+                        break;
                     case HWC_FRAMEBUFFER_TARGET: {
                         // this should not happen as the iterator shouldn't
                         // let us get there.
@@ -2637,6 +2795,9 @@ status_t SurfaceFlinger::onTransact(
             const int pid = ipc->getCallingPid();
             const int uid = ipc->getCallingUid();
             if ((uid != AID_GRAPHICS) &&
+#if defined(USE_MHEAP_SCREENSHOT) || defined(BOARD_EGL_NEEDS_LEGACY_FB)
+                 (uid != AID_SYSTEM) &&
+#endif
                     !PermissionCache::checkPermission(sAccessSurfaceFlinger, pid, uid)) {
                 ALOGE("Permission Denial: "
                         "can't access SurfaceFlinger pid=%d, uid=%d", pid, uid);
@@ -2645,6 +2806,9 @@ status_t SurfaceFlinger::onTransact(
             break;
         }
         case CAPTURE_SCREEN:
+#ifdef USE_MHEAP_SCREENSHOT
+        case CAPTURE_SCREEN_DEPRECATED:
+#endif
         {
             // codes that require permission check
             IPCThreadState* ipc = IPCThreadState::self();
@@ -2848,7 +3012,8 @@ public:
 status_t SurfaceFlinger::captureScreen(const sp<IBinder>& display,
         const sp<IGraphicBufferProducer>& producer,
         uint32_t reqWidth, uint32_t reqHeight,
-        uint32_t minLayerZ, uint32_t maxLayerZ) {
+        uint32_t minLayerZ, uint32_t maxLayerZ,
+        bool useReadPixels) {
 
     if (CC_UNLIKELY(display == 0))
         return BAD_VALUE;
@@ -2874,16 +3039,18 @@ status_t SurfaceFlinger::captureScreen(const sp<IBinder>& display,
         sp<IGraphicBufferProducer> producer;
         uint32_t reqWidth, reqHeight;
         uint32_t minLayerZ,maxLayerZ;
+        bool useReadPixels;
         status_t result;
     public:
         MessageCaptureScreen(SurfaceFlinger* flinger,
                 const sp<IBinder>& display,
                 const sp<IGraphicBufferProducer>& producer,
                 uint32_t reqWidth, uint32_t reqHeight,
-                uint32_t minLayerZ, uint32_t maxLayerZ)
+                uint32_t minLayerZ, uint32_t maxLayerZ, bool useReadPixels)
             : flinger(flinger), display(display), producer(producer),
               reqWidth(reqWidth), reqHeight(reqHeight),
               minLayerZ(minLayerZ), maxLayerZ(maxLayerZ),
+              useReadPixels(useReadPixels),
               result(PERMISSION_DENIED)
         {
         }
@@ -2893,8 +3060,19 @@ status_t SurfaceFlinger::captureScreen(const sp<IBinder>& display,
         virtual bool handler() {
             Mutex::Autolock _l(flinger->mStateLock);
             sp<const DisplayDevice> hw(flinger->getDisplayDevice(display));
-            result = flinger->captureScreenImplLocked(hw,
-                    producer, reqWidth, reqHeight, minLayerZ, maxLayerZ);
+            bool useReadPixels = this->useReadPixels && !flinger->mGpuToCpuSupported;
+#ifdef USE_MHEAP_SCREENSHOT
+            if (!useReadPixels) {
+#endif
+                result = flinger->captureScreenImplLocked(hw,
+                        producer, reqWidth, reqHeight, minLayerZ, maxLayerZ,
+                        useReadPixels);
+#ifdef USE_MHEAP_SCREENSHOT
+            } else {
+                // Should never get here
+                return BAD_VALUE;
+            }
+#endif
             static_cast<GraphicProducerWrapper*>(producer->asBinder().get())->exit(result);
             return true;
         }
@@ -2916,7 +3094,8 @@ status_t SurfaceFlinger::captureScreen(const sp<IBinder>& display,
     // which does the marshaling work forwards to our "fake remote" above.
     sp<MessageBase> msg = new MessageCaptureScreen(this,
             display, IGraphicBufferProducer::asInterface( wrapper ),
-            reqWidth, reqHeight, minLayerZ, maxLayerZ);
+            reqWidth, reqHeight, minLayerZ, maxLayerZ,
+            useReadPixels);
 
     status_t res = postMessageAsync(msg);
     if (res == NO_ERROR) {
@@ -2957,6 +3136,12 @@ void SurfaceFlinger::renderScreenImplLocked(
         const Layer::State& state(layer->getDrawingState());
         if (state.layerStack == hw->getLayerStack()) {
             if (state.z >= minLayerZ && state.z <= maxLayerZ) {
+#ifdef QCOM_BSP
+                // dont render the secure Display Layer
+                if(layer->isSecureDisplay()) {
+                    continue;
+                }
+#endif
                 if (layer->isVisible()) {
                     if (filtering) layer->setFiltering(true);
                     layer->draw(hw);
@@ -2976,7 +3161,8 @@ status_t SurfaceFlinger::captureScreenImplLocked(
         const sp<const DisplayDevice>& hw,
         const sp<IGraphicBufferProducer>& producer,
         uint32_t reqWidth, uint32_t reqHeight,
-        uint32_t minLayerZ, uint32_t maxLayerZ)
+        uint32_t minLayerZ, uint32_t maxLayerZ,
+        bool useReadPixels)
 {
     ATRACE_CALL();
 
@@ -3023,7 +3209,7 @@ status_t SurfaceFlinger::captureScreenImplLocked(
                 if (image != EGL_NO_IMAGE_KHR) {
                     // this binds the given EGLImage as a framebuffer for the
                     // duration of this scope.
-                    RenderEngine::BindImageAsFramebuffer imageBond(getRenderEngine(), image);
+                    RenderEngine::BindImageAsFramebuffer imageBond(getRenderEngine(), image, useReadPixels, reqWidth, reqHeight);
                     if (imageBond.getStatus() == NO_ERROR) {
                         // this will in fact render into our dequeued buffer
                         // via an FBO, which means we didn't have to create
@@ -3053,6 +3239,15 @@ status_t SurfaceFlinger::captureScreenImplLocked(
                             // not fatal
                         }
 
+                        if (useReadPixels) {
+                            sp<GraphicBuffer> buf = static_cast<GraphicBuffer*>(buffer);
+                            void* vaddr;
+                            if (buf->lock(GRALLOC_USAGE_SW_WRITE_OFTEN, &vaddr) == NO_ERROR) {
+                                getRenderEngine().readPixels(0, 0, buffer->stride, reqHeight, (uint32_t *)vaddr);
+                                buf->unlock();
+                            }
+                        }
+
                         if (DEBUG_SCREENSHOTS) {
                             uint32_t* pixels = new uint32_t[reqWidth*reqHeight];
                             getRenderEngine().readPixels(0, 0, reqWidth, reqHeight, pixels);
@@ -3109,6 +3304,108 @@ void SurfaceFlinger::checkScreenshot(size_t w, size_t s, size_t h, void const* v
     }
 }
 
+#ifdef USE_MHEAP_SCREENSHOT
+status_t SurfaceFlinger::captureScreenImplCpuConsumerLocked(
+        const sp<const DisplayDevice>& hw,
+        sp<IMemoryHeap>* heap, uint32_t* w, uint32_t* h,
+        uint32_t reqWidth, uint32_t reqHeight,
+        uint32_t minLayerZ, uint32_t maxLayerZ)
+{
+    ATRACE_CALL();
+
+    // get screen geometry
+    const uint32_t hw_w = hw->getWidth();
+    const uint32_t hw_h = hw->getHeight();
+
+    if ((reqWidth > hw_w) || (reqHeight > hw_h)) {
+        ALOGE("size mismatch (%d, %d) > (%d, %d)",
+                reqWidth, reqHeight, hw_w, hw_h);
+        return BAD_VALUE;
+    }
+
+    reqWidth  = (!reqWidth)  ? hw_w : reqWidth;
+    reqHeight = (!reqHeight) ? hw_h : reqHeight;
+
+    status_t result = NO_ERROR;
+
+    renderScreenImplLocked(hw, reqWidth, reqHeight, minLayerZ, maxLayerZ, true);
+
+    size_t size = reqWidth * reqHeight * 4;
+    // allocate shared memory large enough to hold the
+    // screen capture
+    sp<MemoryHeapBase> base(
+            new MemoryHeapBase(size, 0, "screen-capture") );
+    void *vaddr = base->getBase();
+    glReadPixels(0, 0, reqWidth, reqHeight,
+            GL_RGBA, GL_UNSIGNED_BYTE, vaddr);
+    if (glGetError() == GL_NO_ERROR) {
+        *heap = base;
+        *w = reqWidth;
+        *h = reqHeight;
+        result = NO_ERROR;
+    } else {
+        result = INVALID_OPERATION;
+    }
+
+    return result;
+}
+
+status_t SurfaceFlinger::captureScreen(const sp<IBinder>& display,
+        sp<IMemoryHeap>* heap,
+        uint32_t* outWidth, uint32_t* outHeight,
+        uint32_t reqWidth, uint32_t reqHeight,
+        uint32_t minLayerZ, uint32_t maxLayerZ)
+{
+    if (CC_UNLIKELY(display == 0))
+        return BAD_VALUE;
+
+    class MessageCaptureScreen : public MessageBase {
+        SurfaceFlinger* flinger;
+        sp<IBinder> display;
+        sp<IMemoryHeap>* heap;
+        uint32_t* outWidth;
+        uint32_t* outHeight;
+        uint32_t reqWidth;
+        uint32_t reqHeight;
+        uint32_t minLayerZ;
+        uint32_t maxLayerZ;
+        status_t result;
+    public:
+        MessageCaptureScreen(SurfaceFlinger* flinger,
+                const sp<IBinder>& display, sp<IMemoryHeap>* heap,
+                uint32_t* outWidth, uint32_t* outHeight,
+                uint32_t reqWidth, uint32_t reqHeight,
+                uint32_t minLayerZ, uint32_t maxLayerZ)
+            : flinger(flinger), display(display), heap(heap),
+              outWidth(outWidth), outHeight(outHeight),
+              reqWidth(reqWidth), reqHeight(reqHeight),
+              minLayerZ(minLayerZ), maxLayerZ(maxLayerZ),
+              result(PERMISSION_DENIED)
+        {
+        }
+        status_t getResult() const {
+            return result;
+        }
+        virtual bool handler() {
+            Mutex::Autolock _l(flinger->mStateLock);
+            sp<const DisplayDevice> hw(flinger->getDisplayDevice(display));
+            result = flinger->captureScreenImplCpuConsumerLocked(hw, heap,
+                    outWidth, outHeight,
+                    reqWidth, reqHeight, minLayerZ, maxLayerZ);
+            return true;
+        }
+    };
+
+    sp<MessageBase> msg = new MessageCaptureScreen(this, display, heap,
+            outWidth, outHeight, reqWidth, reqHeight, minLayerZ, maxLayerZ);
+    status_t res = postMessageSync(msg);
+    if (res == NO_ERROR) {
+        res = static_cast<MessageCaptureScreen*>( msg.get() )->getResult();
+    }
+    return res;
+}
+#endif
+
 // ---------------------------------------------------------------------------
 
 SurfaceFlinger::LayerVector::LayerVector() {
@@ -3155,6 +3452,7 @@ SurfaceFlinger::DisplayDeviceState::DisplayDeviceState(DisplayDevice::DisplayTyp
 }; // namespace android
 
 
+#ifndef USE_MHEAP_SCREENSHOT
 #if defined(__gl_h_)
 #error "don't include gl/gl.h in this file"
 #endif
@@ -3162,3 +3460,4 @@ SurfaceFlinger::DisplayDeviceState::DisplayDeviceState(DisplayDevice::DisplayTyp
 #if defined(__gl2_h_)
 #error "don't include gl2/gl2.h in this file"
 #endif
+#endif
diff --git a/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp.orig b/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp.orig
index 9d94c87..339e798 100644
--- a/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp.orig
+++ b/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp.orig
@@ -23,6 +23,9 @@
 #include <dlfcn.h>
 
 #include <EGL/egl.h>
+#ifdef USE_MHEAP_SCREENSHOT
+#include <GLES/gl.h>
+#endif
 
 #include <cutils/log.h>
 #include <cutils/properties.h>
@@ -75,6 +78,10 @@
 #include "RenderEngine/RenderEngine.h"
 #include <cutils/compiler.h>
 
+#ifdef SAMSUNG_HDMI_SUPPORT
+#include "SecTVOutService.h"
+#endif
+
 #define DISPLAY_COUNT       1
 
 /*
@@ -150,6 +157,7 @@ SurfaceFlinger::SurfaceFlinger()
         mDebugInTransaction(0),
         mLastTransactionTime(0),
         mBootFinished(false),
+        mUseDithering(false),
         mPrimaryHWVsyncEnabled(false),
         mHWVsyncAvailable(false),
         mDaltonize(false)
@@ -175,6 +183,16 @@ SurfaceFlinger::SurfaceFlinger()
     }
     ALOGI_IF(mDebugRegion, "showupdates enabled");
     ALOGI_IF(mDebugDDMS, "DDMS debugging enabled");
+
+#ifdef SAMSUNG_HDMI_SUPPORT
+    ALOGD(">>> Run service");
+    android::SecTVOutService::instantiate();
+#if defined(SAMSUNG_EXYNOS5250)
+    mHdmiClient = SecHdmiClient::getInstance();
+    mHdmiClient->setHdmiEnable(1);
+#endif
+#endif
+
 }
 
 void SurfaceFlinger::onFirstRef()
@@ -556,6 +574,9 @@ void SurfaceFlinger::init() {
     ALOGI("Client API: %s", eglQueryString(mEGLDisplay, EGL_CLIENT_APIS)?:"Not Supported");
     ALOGI("EGLSurface: %d-%d-%d-%d, config=%p", r, g, b, a, mEGLConfig);
 
+    // assume red has minimum color depth
+    mMinColorDepth = r;
+
     // get a RenderEngine for the given display / config (can't fail)
     mRenderEngine = RenderEngine::create(mEGLDisplay, mEGLConfig);
 
@@ -593,6 +614,9 @@ void SurfaceFlinger::init() {
                 hw->acquireScreen();
             }
             mDisplays.add(token, hw);
+            if (!mUseDithering && bitsPerPixel(mHwc->getFormat(i)) <= 16) {
+                mUseDithering = true;
+            }
         }
     }
 
@@ -605,7 +629,7 @@ void SurfaceFlinger::init() {
             vsyncPhaseOffsetNs, true);
     mEventThread = new EventThread(vsyncSrc);
     sp<VSyncSource> sfVsyncSrc = new DispSyncSource(&mPrimaryDispSync,
-            sfVsyncPhaseOffsetNs, false);
+            sfVsyncPhaseOffsetNs, true);
     mSFEventThread = new EventThread(sfVsyncSrc);
     mEventQueue.setEventThread(mSFEventThread);
 
@@ -715,10 +739,19 @@ status_t SurfaceFlinger::getDisplayInfo(const sp<IBinder>& display, DisplayInfo*
         info->orientation = 0;
     }
 
-    info->w = hwc.getWidth(type);
-    info->h = hwc.getHeight(type);
-    info->xdpi = xdpi;
-    info->ydpi = ydpi;
+    int additionalRot = mDisplays[0]->getHardwareOrientation() / 90;
+    if ((type == DisplayDevice::DISPLAY_PRIMARY) && (additionalRot & DisplayState::eOrientationSwapMask)) {
+        info->h = hwc.getWidth(type);
+        info->w = hwc.getHeight(type);
+        info->xdpi = ydpi;
+        info->ydpi = xdpi;
+    }
+    else {
+        info->w = hwc.getWidth(type);
+        info->h = hwc.getHeight(type);
+        info->xdpi = xdpi;
+        info->ydpi = ydpi;
+    }
     info->fps = float(1e9 / hwc.getRefreshPeriod(type));
 
     // All non-virtual displays are currently considered secure.
@@ -1013,21 +1046,20 @@ void SurfaceFlinger::rebuildLayerStacks() {
             const sp<DisplayDevice>& hw(mDisplays[dpy]);
             const Transform& tr(hw->getTransform());
             const Rect bounds(hw->getBounds());
+            int dpyId = hw->getHwcDisplayId();
             if (hw->canDraw()) {
-                SurfaceFlinger::computeVisibleRegions(layers,
+                SurfaceFlinger::computeVisibleRegions(dpyId, layers,
                         hw->getLayerStack(), dirtyRegion, opaqueRegion);
 
                 const size_t count = layers.size();
                 for (size_t i=0 ; i<count ; i++) {
                     const sp<Layer>& layer(layers[i]);
                     const Layer::State& s(layer->getDrawingState());
-                    if (s.layerStack == hw->getLayerStack()) {
-                        Region drawRegion(tr.transform(
-                                layer->visibleNonTransparentRegion));
-                        drawRegion.andSelf(bounds);
-                        if (!drawRegion.isEmpty()) {
-                            layersSortedByZ.add(layer);
-                        }
+                    Region drawRegion(tr.transform(
+                            layer->visibleNonTransparentRegion));
+                    drawRegion.andSelf(bounds);
+                    if (!drawRegion.isEmpty()) {
+                        layersSortedByZ.add(layer);
                     }
                 }
             }
@@ -1076,6 +1108,26 @@ void SurfaceFlinger::setUpHWComposer() {
             sp<const DisplayDevice> hw(mDisplays[dpy]);
             const int32_t id = hw->getHwcDisplayId();
             if (id >= 0) {
+                // Get the layers in the current drawying state
+                const LayerVector& layers(mDrawingState.layersSortedByZ);
+                bool freezeSurfacePresent = false;
+                const size_t layerCount = layers.size();
+                char value[PROPERTY_VALUE_MAX];
+                property_get("sys.disable_ext_animation", value, "0");
+                if(atoi(value)) {
+                    for (size_t i = 0 ; i < layerCount ; ++i) {
+                        static int screenShotLen = strlen("ScreenshotSurface");
+                        const sp<Layer>& layer(layers[i]);
+                        if(!strncmp(layer->getName(), "ScreenshotSurface",
+                                    screenShotLen)) {
+                            // Screenshot layer is present, and animation in
+                            // progress
+                            freezeSurfacePresent = true;
+                            break;
+                        }
+                    }
+                }
+
                 const Vector< sp<Layer> >& currentLayers(
                     hw->getVisibleLayersSortedByZ());
                 const size_t count = currentLayers.size();
@@ -1088,6 +1140,26 @@ void SurfaceFlinger::setUpHWComposer() {
                      */
                     const sp<Layer>& layer(currentLayers[i]);
                     layer->setPerFrameData(hw, *cur);
+                    if(freezeSurfacePresent) {
+                        // if freezeSurfacePresent, set ANIMATING flag
+                        cur->setAnimating(true);
+                    } else {
+                        const KeyedVector<wp<IBinder>, DisplayDeviceState>&
+                                                draw(mDrawingState.displays);
+                        size_t dc = draw.size();
+                        for (size_t i=0 ; i<dc ; i++) {
+                            if (draw[i].isMainDisplay()) {
+                                HWComposer& hwc(getHwComposer());
+                                if (hwc.initCheck() == NO_ERROR)
+                                    // Pass the current orientation to HWC
+                                    // which will be used to block animation
+                                    // on external
+                                    hwc.eventControl(HWC_DISPLAY_PRIMARY,
+                                            SurfaceFlinger::EVENT_ORIENTATION,
+                                            uint32_t(draw[i].orientation));
+                            }
+                        }
+                    }
                 }
             }
         }
@@ -1205,6 +1277,26 @@ void SurfaceFlinger::handleTransaction(uint32_t transactionFlags)
     // here the transaction has been committed
 }
 
+void SurfaceFlinger::setVirtualDisplayData(
+    int32_t hwcDisplayId,
+    const sp<IGraphicBufferProducer>& sink)
+{
+    sp<ANativeWindow> mNativeWindow = new Surface(sink);
+    ANativeWindow* const window = mNativeWindow.get();
+
+    int format;
+    window->query(window, NATIVE_WINDOW_FORMAT, &format);
+
+    EGLSurface surface;
+    EGLint w, h;
+    EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
+    surface = eglCreateWindowSurface(display, mEGLConfig, window, NULL);
+    eglQuerySurface(display, surface, EGL_WIDTH,  &w);
+    eglQuerySurface(display, surface, EGL_HEIGHT, &h);
+
+    mHwc->setVirtualDisplayProperties(hwcDisplayId, w, h, format);
+}
+
 void SurfaceFlinger::handleTransactionLocked(uint32_t transactionFlags)
 {
     const LayerVector& currentLayers(mCurrentState.layersSortedByZ);
@@ -1317,18 +1409,32 @@ void SurfaceFlinger::handleTransactionLocked(uint32_t transactionFlags)
                         // etc.) but no internal state (i.e. a DisplayDevice).
                         if (state.surface != NULL) {
 
+                            char value[PROPERTY_VALUE_MAX];
                             hwcDisplayId = allocateHwcDisplayId(state.type);
-                            sp<VirtualDisplaySurface> vds = new VirtualDisplaySurface(
+                            property_get("persist.sys.wfd.virtual", value, "0");
+                            int wfdVirtual = atoi(value);
+                            if(!wfdVirtual) {
+                                sp<VirtualDisplaySurface> vds =
+                                              new VirtualDisplaySurface(
                                     *mHwc, hwcDisplayId, state.surface, bq,
                                     state.displayName);
-
-                            dispSurface = vds;
-                            if (hwcDisplayId >= 0) {
-                                producer = vds;
+                                dispSurface = vds;
+                                if (hwcDisplayId >= 0) {
+                                   producer = vds;
+                                } else {
+                                  // There won't be any interaction with HWC for this virtual display,
+                                  // so the GLES driver can pass buffers directly to the sink.
+                                  producer = state.surface;
+                                }
                             } else {
-                                // There won't be any interaction with HWC for this virtual display,
-                                // so the GLES driver can pass buffers directly to the sink.
-                                producer = state.surface;
+                                //Read virtual display properties and create a
+                                //rendering surface for it inorder to be handled
+                                //by hwc.
+                                setVirtualDisplayData(hwcDisplayId,
+                                                                 state.surface);
+                                dispSurface = new FramebufferSurface(*mHwc,
+                                                                    state.type, bq);
+                                producer = bq;
                             }
                         }
                     } else {
@@ -1344,7 +1450,7 @@ void SurfaceFlinger::handleTransactionLocked(uint32_t transactionFlags)
                     }
 
                     const wp<IBinder>& display(curr.keyAt(i));
-                    if (dispSurface != NULL) {
+                    if (dispSurface != NULL && producer != NULL) {
                         sp<DisplayDevice> hw = new DisplayDevice(this,
                                 state.type, hwcDisplayId, state.isSecure,
                                 display, dispSurface, producer, mEGLConfig);
@@ -1482,7 +1588,7 @@ void SurfaceFlinger::commitTransaction()
     mTransactionCV.broadcast();
 }
 
-void SurfaceFlinger::computeVisibleRegions(
+void SurfaceFlinger::computeVisibleRegions(size_t dpy,
         const LayerVector& currentLayers, uint32_t layerStack,
         Region& outDirtyRegion, Region& outOpaqueRegion)
 {
@@ -1493,18 +1599,63 @@ void SurfaceFlinger::computeVisibleRegions(
     Region dirty;
 
     outDirtyRegion.clear();
-
+    bool bIgnoreLayers = false;
+    int indexLOI = -1;
     size_t i = currentLayers.size();
+#ifdef QCOM_BSP
+    while (i--) {
+        const sp<Layer>& layer = currentLayers[i];
+        // iterate through the layer list to find ext_only layers and store
+        // the index
+        if (layer->isSecureDisplay()) {
+            bIgnoreLayers = true;
+            indexLOI = -1;
+            if(!dpy)
+                indexLOI = i;
+            break;
+        }
+
+        if (dpy && layer->isExtOnly()) {
+            bIgnoreLayers = true;
+            indexLOI = i;
+        }
+    }
+    i = currentLayers.size();
+#endif
     while (i--) {
         const sp<Layer>& layer = currentLayers[i];
 
         // start with the whole surface at its current location
         const Layer::State& s(layer->getDrawingState());
 
-        // only consider the layers on the given layer stack
-        if (s.layerStack != layerStack)
+#ifdef QCOM_BSP
+        // Only add the layer marked as "external_only" to external list and
+        // only remove the layer marked as "external_only" from primary list
+        // and do not add the layer marked as "internal_only" to external list
+        // Add secure UI layers to primary and remove other layers from internal
+        //and external list
+        if((bIgnoreLayers && indexLOI != (int)i) ||
+           (!dpy && layer->isExtOnly()) ||
+           (dpy && layer->isIntOnly())) {
+            // Ignore all other layers except the layers marked as ext_only
+            // by setting visible non transparent region empty.
+            Region visibleNonTransRegion;
+            visibleNonTransRegion.set(Rect(0,0));
+            layer->setVisibleNonTransparentRegion(visibleNonTransRegion);
             continue;
-
+        }
+#endif
+        // only consider the layers on the given later stack
+        // Override layers created using presentation class by the layers having
+        // ext_only flag enabled
+        if(s.layerStack != layerStack && !bIgnoreLayers) {
+            // set the visible region as empty since we have removed the
+            // layerstack check in rebuildLayerStack() function.
+            Region visibleNonTransRegion;
+            visibleNonTransRegion.set(Rect(0,0));
+            layer->setVisibleNonTransparentRegion(visibleNonTransRegion);
+            continue;
+        }
         /*
          * opaqueRegion: area of a surface that is fully opaque.
          */
@@ -1740,8 +1891,12 @@ void SurfaceFlinger::doComposeSurfaces(const sp<const DisplayDevice>& hw, const
 
             // screen is already cleared here
             if (!region.isEmpty()) {
-                // can happen with SurfaceView
-                drawWormhole(hw, region);
+                if (cur != end) {
+                    if (cur->getCompositionType() != HWC_BLIT)
+                        // can happen with SurfaceView
+                        drawWormhole(hw, region);
+                } else
+                    drawWormhole(hw, region);
             }
         }
 
@@ -1794,6 +1949,9 @@ void SurfaceFlinger::doComposeSurfaces(const sp<const DisplayDevice>& hw, const
                         layer->draw(hw, clip);
                         break;
                     }
+                    case HWC_BLIT:
+                        //Do nothing
+                        break;
                     case HWC_FRAMEBUFFER_TARGET: {
                         // this should not happen as the iterator shouldn't
                         // let us get there.
@@ -2637,6 +2795,9 @@ status_t SurfaceFlinger::onTransact(
             const int pid = ipc->getCallingPid();
             const int uid = ipc->getCallingUid();
             if ((uid != AID_GRAPHICS) &&
+#ifdef USE_MHEAP_SCREENSHOT
+                 (uid != AID_SYSTEM) &&
+#endif
                     !PermissionCache::checkPermission(sAccessSurfaceFlinger, pid, uid)) {
                 ALOGE("Permission Denial: "
                         "can't access SurfaceFlinger pid=%d, uid=%d", pid, uid);
@@ -2645,6 +2806,9 @@ status_t SurfaceFlinger::onTransact(
             break;
         }
         case CAPTURE_SCREEN:
+#ifdef USE_MHEAP_SCREENSHOT
+        case CAPTURE_SCREEN_DEPRECATED:
+#endif
         {
             // codes that require permission check
             IPCThreadState* ipc = IPCThreadState::self();
@@ -2839,7 +3003,8 @@ public:
 status_t SurfaceFlinger::captureScreen(const sp<IBinder>& display,
         const sp<IGraphicBufferProducer>& producer,
         uint32_t reqWidth, uint32_t reqHeight,
-        uint32_t minLayerZ, uint32_t maxLayerZ) {
+        uint32_t minLayerZ, uint32_t maxLayerZ,
+        bool useReadPixels) {
 
     if (CC_UNLIKELY(display == 0))
         return BAD_VALUE;
@@ -2865,16 +3030,18 @@ status_t SurfaceFlinger::captureScreen(const sp<IBinder>& display,
         sp<IGraphicBufferProducer> producer;
         uint32_t reqWidth, reqHeight;
         uint32_t minLayerZ,maxLayerZ;
+        bool useReadPixels;
         status_t result;
     public:
         MessageCaptureScreen(SurfaceFlinger* flinger,
                 const sp<IBinder>& display,
                 const sp<IGraphicBufferProducer>& producer,
                 uint32_t reqWidth, uint32_t reqHeight,
-                uint32_t minLayerZ, uint32_t maxLayerZ)
+                uint32_t minLayerZ, uint32_t maxLayerZ, bool useReadPixels)
             : flinger(flinger), display(display), producer(producer),
               reqWidth(reqWidth), reqHeight(reqHeight),
               minLayerZ(minLayerZ), maxLayerZ(maxLayerZ),
+              useReadPixels(useReadPixels),
               result(PERMISSION_DENIED)
         {
         }
@@ -2884,8 +3051,19 @@ status_t SurfaceFlinger::captureScreen(const sp<IBinder>& display,
         virtual bool handler() {
             Mutex::Autolock _l(flinger->mStateLock);
             sp<const DisplayDevice> hw(flinger->getDisplayDevice(display));
-            result = flinger->captureScreenImplLocked(hw,
-                    producer, reqWidth, reqHeight, minLayerZ, maxLayerZ);
+            bool useReadPixels = this->useReadPixels && !flinger->mGpuToCpuSupported;
+#ifdef USE_MHEAP_SCREENSHOT
+            if (!useReadPixels) {
+#endif
+                result = flinger->captureScreenImplLocked(hw,
+                        producer, reqWidth, reqHeight, minLayerZ, maxLayerZ,
+                        useReadPixels);
+#ifdef USE_MHEAP_SCREENSHOT
+            } else {
+                // Should never get here
+                return BAD_VALUE;
+            }
+#endif
             static_cast<GraphicProducerWrapper*>(producer->asBinder().get())->exit(result);
             return true;
         }
@@ -2907,7 +3085,8 @@ status_t SurfaceFlinger::captureScreen(const sp<IBinder>& display,
     // which does the marshaling work forwards to our "fake remote" above.
     sp<MessageBase> msg = new MessageCaptureScreen(this,
             display, IGraphicBufferProducer::asInterface( wrapper ),
-            reqWidth, reqHeight, minLayerZ, maxLayerZ);
+            reqWidth, reqHeight, minLayerZ, maxLayerZ,
+            useReadPixels);
 
     status_t res = postMessageAsync(msg);
     if (res == NO_ERROR) {
@@ -2948,6 +3127,12 @@ void SurfaceFlinger::renderScreenImplLocked(
         const Layer::State& state(layer->getDrawingState());
         if (state.layerStack == hw->getLayerStack()) {
             if (state.z >= minLayerZ && state.z <= maxLayerZ) {
+#ifdef QCOM_BSP
+                // dont render the secure Display Layer
+                if(layer->isSecureDisplay()) {
+                    continue;
+                }
+#endif
                 if (layer->isVisible()) {
                     if (filtering) layer->setFiltering(true);
                     layer->draw(hw);
@@ -2967,7 +3152,8 @@ status_t SurfaceFlinger::captureScreenImplLocked(
         const sp<const DisplayDevice>& hw,
         const sp<IGraphicBufferProducer>& producer,
         uint32_t reqWidth, uint32_t reqHeight,
-        uint32_t minLayerZ, uint32_t maxLayerZ)
+        uint32_t minLayerZ, uint32_t maxLayerZ,
+        bool useReadPixels)
 {
     ATRACE_CALL();
 
@@ -3014,7 +3200,7 @@ status_t SurfaceFlinger::captureScreenImplLocked(
                 if (image != EGL_NO_IMAGE_KHR) {
                     // this binds the given EGLImage as a framebuffer for the
                     // duration of this scope.
-                    RenderEngine::BindImageAsFramebuffer imageBond(getRenderEngine(), image);
+                    RenderEngine::BindImageAsFramebuffer imageBond(getRenderEngine(), image, useReadPixels, reqWidth, reqHeight);
                     if (imageBond.getStatus() == NO_ERROR) {
                         // this will in fact render into our dequeued buffer
                         // via an FBO, which means we didn't have to create
@@ -3044,6 +3230,15 @@ status_t SurfaceFlinger::captureScreenImplLocked(
                             // not fatal
                         }
 
+                        if (useReadPixels) {
+                            sp<GraphicBuffer> buf = static_cast<GraphicBuffer*>(buffer);
+                            void* vaddr;
+                            if (buf->lock(GRALLOC_USAGE_SW_WRITE_OFTEN, &vaddr) == NO_ERROR) {
+                                getRenderEngine().readPixels(0, 0, buffer->stride, reqHeight, (uint32_t *)vaddr);
+                                buf->unlock();
+                            }
+                        }
+
                         if (DEBUG_SCREENSHOTS) {
                             uint32_t* pixels = new uint32_t[reqWidth*reqHeight];
                             getRenderEngine().readPixels(0, 0, reqWidth, reqHeight, pixels);
@@ -3100,6 +3295,108 @@ void SurfaceFlinger::checkScreenshot(size_t w, size_t s, size_t h, void const* v
     }
 }
 
+#ifdef USE_MHEAP_SCREENSHOT
+status_t SurfaceFlinger::captureScreenImplCpuConsumerLocked(
+        const sp<const DisplayDevice>& hw,
+        sp<IMemoryHeap>* heap, uint32_t* w, uint32_t* h,
+        uint32_t reqWidth, uint32_t reqHeight,
+        uint32_t minLayerZ, uint32_t maxLayerZ)
+{
+    ATRACE_CALL();
+
+    // get screen geometry
+    const uint32_t hw_w = hw->getWidth();
+    const uint32_t hw_h = hw->getHeight();
+
+    if ((reqWidth > hw_w) || (reqHeight > hw_h)) {
+        ALOGE("size mismatch (%d, %d) > (%d, %d)",
+                reqWidth, reqHeight, hw_w, hw_h);
+        return BAD_VALUE;
+    }
+
+    reqWidth  = (!reqWidth)  ? hw_w : reqWidth;
+    reqHeight = (!reqHeight) ? hw_h : reqHeight;
+
+    status_t result = NO_ERROR;
+
+    renderScreenImplLocked(hw, reqWidth, reqHeight, minLayerZ, maxLayerZ, true);
+
+    size_t size = reqWidth * reqHeight * 4;
+    // allocate shared memory large enough to hold the
+    // screen capture
+    sp<MemoryHeapBase> base(
+            new MemoryHeapBase(size, 0, "screen-capture") );
+    void *vaddr = base->getBase();
+    glReadPixels(0, 0, reqWidth, reqHeight,
+            GL_RGBA, GL_UNSIGNED_BYTE, vaddr);
+    if (glGetError() == GL_NO_ERROR) {
+        *heap = base;
+        *w = reqWidth;
+        *h = reqHeight;
+        result = NO_ERROR;
+    } else {
+        result = INVALID_OPERATION;
+    }
+
+    return result;
+}
+
+status_t SurfaceFlinger::captureScreen(const sp<IBinder>& display,
+        sp<IMemoryHeap>* heap,
+        uint32_t* outWidth, uint32_t* outHeight,
+        uint32_t reqWidth, uint32_t reqHeight,
+        uint32_t minLayerZ, uint32_t maxLayerZ)
+{
+    if (CC_UNLIKELY(display == 0))
+        return BAD_VALUE;
+
+    class MessageCaptureScreen : public MessageBase {
+        SurfaceFlinger* flinger;
+        sp<IBinder> display;
+        sp<IMemoryHeap>* heap;
+        uint32_t* outWidth;
+        uint32_t* outHeight;
+        uint32_t reqWidth;
+        uint32_t reqHeight;
+        uint32_t minLayerZ;
+        uint32_t maxLayerZ;
+        status_t result;
+    public:
+        MessageCaptureScreen(SurfaceFlinger* flinger,
+                const sp<IBinder>& display, sp<IMemoryHeap>* heap,
+                uint32_t* outWidth, uint32_t* outHeight,
+                uint32_t reqWidth, uint32_t reqHeight,
+                uint32_t minLayerZ, uint32_t maxLayerZ)
+            : flinger(flinger), display(display), heap(heap),
+              outWidth(outWidth), outHeight(outHeight),
+              reqWidth(reqWidth), reqHeight(reqHeight),
+              minLayerZ(minLayerZ), maxLayerZ(maxLayerZ),
+              result(PERMISSION_DENIED)
+        {
+        }
+        status_t getResult() const {
+            return result;
+        }
+        virtual bool handler() {
+            Mutex::Autolock _l(flinger->mStateLock);
+            sp<const DisplayDevice> hw(flinger->getDisplayDevice(display));
+            result = flinger->captureScreenImplCpuConsumerLocked(hw, heap,
+                    outWidth, outHeight,
+                    reqWidth, reqHeight, minLayerZ, maxLayerZ);
+            return true;
+        }
+    };
+
+    sp<MessageBase> msg = new MessageCaptureScreen(this, display, heap,
+            outWidth, outHeight, reqWidth, reqHeight, minLayerZ, maxLayerZ);
+    status_t res = postMessageSync(msg);
+    if (res == NO_ERROR) {
+        res = static_cast<MessageCaptureScreen*>( msg.get() )->getResult();
+    }
+    return res;
+}
+#endif
+
 // ---------------------------------------------------------------------------
 
 SurfaceFlinger::LayerVector::LayerVector() {
@@ -3146,6 +3443,7 @@ SurfaceFlinger::DisplayDeviceState::DisplayDeviceState(DisplayDevice::DisplayTyp
 }; // namespace android
 
 
+#ifndef USE_MHEAP_SCREENSHOT
 #if defined(__gl_h_)
 #error "don't include gl/gl.h in this file"
 #endif
@@ -3153,3 +3451,4 @@ SurfaceFlinger::DisplayDeviceState::DisplayDeviceState(DisplayDevice::DisplayTyp
 #if defined(__gl2_h_)
 #error "don't include gl2/gl2.h in this file"
 #endif
+#endif
diff --git a/frameworks/native/services/surfaceflinger/SurfaceFlinger.h b/frameworks/native/services/surfaceflinger/SurfaceFlinger.h
index f08e66a..ada2914 100644
--- a/frameworks/native/services/surfaceflinger/SurfaceFlinger.h
+++ b/frameworks/native/services/surfaceflinger/SurfaceFlinger.h
@@ -55,6 +55,10 @@
 #include "DisplayHardware/HWComposer.h"
 #include "Effects/Daltonizer.h"
 
+#ifdef SAMSUNG_HDMI_SUPPORT
+#include "SecHdmiClient.h"
+#endif
+
 namespace android {
 
 // ---------------------------------------------------------------------------
@@ -96,7 +100,8 @@ public:
     void run() ANDROID_API;
 
     enum {
-        EVENT_VSYNC = HWC_EVENT_VSYNC
+        EVENT_VSYNC = HWC_EVENT_VSYNC,
+        EVENT_ORIENTATION = HWC_EVENT_ORIENTATION
     };
 
     // post an asynchronous message to the main thread
@@ -202,7 +207,12 @@ private:
     virtual status_t captureScreen(const sp<IBinder>& display,
             const sp<IGraphicBufferProducer>& producer,
             uint32_t reqWidth, uint32_t reqHeight,
-            uint32_t minLayerZ, uint32_t maxLayerZ);
+            uint32_t minLayerZ, uint32_t maxLayerZ, bool isCpuConsumer);
+#ifdef USE_MHEAP_SCREENSHOT
+    virtual status_t captureScreen(const sp<IBinder>& display, sp<IMemoryHeap>* heap,
+        uint32_t* width, uint32_t* height, uint32_t reqWidth,
+        uint32_t reqHeight, uint32_t minLayerZ, uint32_t maxLayerZ);
+#endif
     // called when screen needs to turn off
     virtual void blank(const sp<IBinder>& display);
     // called when screen is turning back on
@@ -247,6 +257,10 @@ private:
     void handleTransaction(uint32_t transactionFlags);
     void handleTransactionLocked(uint32_t transactionFlags);
 
+    // Read virtual display properties
+    void setVirtualDisplayData( int32_t hwcDisplayId,
+                                const sp<IGraphicBufferProducer>& sink);
+
     /* handlePageFilp: this is were we latch a new buffer
      * if available and compute the dirty region.
      */
@@ -312,7 +326,16 @@ private:
             const sp<const DisplayDevice>& hw,
             const sp<IGraphicBufferProducer>& producer,
             uint32_t reqWidth, uint32_t reqHeight,
+            uint32_t minLayerZ, uint32_t maxLayerZ,
+            bool useReadPixels);
+
+#ifdef USE_MHEAP_SCREENSHOT
+    status_t captureScreenImplCpuConsumerLocked(
+            const sp<const DisplayDevice>& hw,
+            sp<IMemoryHeap>* heap, uint32_t* width, uint32_t* height,
+            uint32_t reqWidth, uint32_t reqHeight,
             uint32_t minLayerZ, uint32_t maxLayerZ);
+#endif
 
     /* ------------------------------------------------------------------------
      * EGL
@@ -324,6 +347,9 @@ private:
     size_t getMaxTextureSize() const;
     size_t getMaxViewportDims() const;
 
+    uint32_t getMinColorDepth() const { return mMinColorDepth; }
+    inline bool getUseDithering() const { return mUseDithering; }
+
     /* ------------------------------------------------------------------------
      * Display and layer stack management
      */
@@ -360,7 +386,7 @@ private:
      * Compositing
      */
     void invalidateHwcGeometry();
-    static void computeVisibleRegions(
+    static void computeVisibleRegions(size_t dpy,
             const LayerVector& currentLayers, uint32_t layerStack,
             Region& dirtyRegion, Region& opaqueRegion);
 
@@ -430,6 +456,7 @@ private:
     sp<EventThread> mEventThread;
     sp<EventThread> mSFEventThread;
     sp<EventControlThread> mEventControlThread;
+    uint32_t mMinColorDepth;
     EGLContext mEGLContext;
     EGLConfig mEGLConfig;
     EGLDisplay mEGLDisplay;
@@ -457,6 +484,7 @@ private:
     volatile nsecs_t mDebugInTransaction;
     nsecs_t mLastTransactionTime;
     bool mBootFinished;
+    bool mUseDithering;
 
     // these are thread safe
     mutable MessageQueue mEventQueue;
@@ -478,6 +506,9 @@ private:
 
     Daltonizer mDaltonizer;
     bool mDaltonize;
+#if defined(SAMSUNG_HDMI_SUPPORT) && defined(SAMSUNG_EXYNOS5250)
+    SecHdmiClient *                         mHdmiClient;
+#endif
 };
 
 }; // namespace android
